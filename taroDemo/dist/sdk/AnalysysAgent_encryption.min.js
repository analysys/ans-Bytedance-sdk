"use strict"; var t = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function e (t, e) { return t(e = { exports: {} }, e.exports), e.exports } var n = e(function (t, e) { var r; t.exports = (r = r || function (d) { var r = Object.create || function (t) { var e; return n.prototype = t, e = new n, n.prototype = null, e }; function n () { } var t = {}, e = t.lib = {}, i = e.Base = { extend: function (t) { var e = r(this); return t && e.mixIn(t), e.hasOwnProperty("init") && this.init !== e.init || (e.init = function () { e.$super.init.apply(this, arguments) }), (e.init.prototype = e).$super = this, e }, create: function () { var t = this.extend(); return t.init.apply(t, arguments), t }, init: function () { }, mixIn: function (t) { for (var e in t) t.hasOwnProperty(e) && (this[e] = t[e]); t.hasOwnProperty("toString") && (this.toString = t.toString) }, clone: function () { return this.init.prototype.extend(this) } }, f = e.WordArray = i.extend({ init: function (t, e) { t = this.words = t || [], this.sigBytes = null != e ? e : 4 * t.length }, toString: function (t) { return (t || s).stringify(this) }, concat: function (t) { var e = this.words, r = t.words, n = this.sigBytes, i = t.sigBytes; if (this.clamp(), n % 4) for (var a = 0; a < i; a++) { var s = r[a >>> 2] >>> 24 - a % 4 * 8 & 255; e[n + a >>> 2] |= s << 24 - (n + a) % 4 * 8 } else for (a = 0; a < i; a += 4)e[n + a >>> 2] = r[a >>> 2]; return this.sigBytes += i, this }, clamp: function () { var t = this.words, e = this.sigBytes; t[e >>> 2] &= 4294967295 << 32 - e % 4 * 8, t.length = d.ceil(e / 4) }, clone: function () { var t = i.clone.call(this); return t.words = this.words.slice(0), t }, random: function (t) { for (var e = [], r = 0; r < t; r += 4) { var n = function (e) { var e = e, r = 987654321, n = 4294967295; return function () { var t = ((r = 36969 * (65535 & r) + (r >> 16) & n) << 16) + (e = 18e3 * (65535 & e) + (e >> 16) & n) & n; return t /= 4294967296, (t += .5) * (.5 < d.random() ? 1 : -1) } }(4294967296 * (i || d.random())), i = 987654071 * n(); e.push(4294967296 * n() | 0) } return new f.init(e, t) } }), a = t.enc = {}, s = a.Hex = { stringify: function (t) { for (var e = t.words, r = t.sigBytes, n = [], i = 0; i < r; i++) { var a = e[i >>> 2] >>> 24 - i % 4 * 8 & 255; n.push((a >>> 4).toString(16)), n.push((15 & a).toString(16)) } return n.join("") }, parse: function (t) { for (var e = t.length, r = [], n = 0; n < e; n += 2)r[n >>> 3] |= parseInt(t.substr(n, 2), 16) << 24 - n % 8 * 4; return new f.init(r, e / 2) } }, o = a.Latin1 = { stringify: function (t) { for (var e = t.words, r = t.sigBytes, n = [], i = 0; i < r; i++) { var a = e[i >>> 2] >>> 24 - i % 4 * 8 & 255; n.push(String.fromCharCode(a)) } return n.join("") }, parse: function (t) { for (var e = t.length, r = [], n = 0; n < e; n++)r[n >>> 2] |= (255 & t.charCodeAt(n)) << 24 - n % 4 * 8; return new f.init(r, e) } }, h = a.Utf8 = { stringify: function (t) { try { return decodeURIComponent(escape(o.stringify(t))) } catch (t) { throw new Error("Malformed UTF-8 data") } }, parse: function (t) { return o.parse(unescape(encodeURIComponent(t))) } }, l = e.BufferedBlockAlgorithm = i.extend({ reset: function () { this._data = new f.init, this._nDataBytes = 0 }, _append: function (t) { "string" == typeof t && (t = h.parse(t)), this._data.concat(t), this._nDataBytes += t.sigBytes }, _process: function (t) { var e = this._data, r = e.words, n = e.sigBytes, i = this.blockSize, a = n / (4 * i), s = (a = t ? d.ceil(a) : d.max((0 | a) - this._minBufferSize, 0)) * i, o = d.min(4 * s, n); if (s) { for (var h = 0; h < s; h += i)this._doProcessBlock(r, h); var l = r.splice(0, s); e.sigBytes -= o } return new f.init(l, o) }, clone: function () { var t = i.clone.call(this); return t._data = this._data.clone(), t }, _minBufferSize: 0 }), c = (e.Hasher = l.extend({ cfg: i.extend(), init: function (t) { this.cfg = this.cfg.extend(t), this.reset() }, reset: function () { l.reset.call(this), this._doReset() }, update: function (t) { return this._append(t), this._process(), this }, finalize: function (t) { return t && this._append(t), this._doFinalize() }, blockSize: 16, _createHelper: function (r) { return function (t, e) { return new r.init(e).finalize(t) } }, _createHmacHelper: function (r) { return function (t, e) { return new c.HMAC.init(r, e).finalize(t) } } }), t.algo = {}); return t }(Math), r) }), l = e(function (t, e) { t.exports = n.enc.Utf8 }), r = e(function (t, e) { var r; t.exports = (r = n, function () { var h = r.lib.WordArray; r.enc.Base64 = { stringify: function (t) { var e = t.words, r = t.sigBytes, n = this._map; t.clamp(); for (var i = [], a = 0; a < r; a += 3)for (var s = (e[a >>> 2] >>> 24 - a % 4 * 8 & 255) << 16 | (e[a + 1 >>> 2] >>> 24 - (a + 1) % 4 * 8 & 255) << 8 | e[a + 2 >>> 2] >>> 24 - (a + 2) % 4 * 8 & 255, o = 0; o < 4 && a + .75 * o < r; o++)i.push(n.charAt(s >>> 6 * (3 - o) & 63)); var h = n.charAt(64); if (h) for (; i.length % 4;)i.push(h); return i.join("") }, parse: function (t) { var e = t.length, r = this._map, n = this._reverseMap; if (!n) { n = this._reverseMap = []; for (var i = 0; i < r.length; i++)n[r.charCodeAt(i)] = i } var a, s = r.charAt(64); return !s || -1 !== (a = t.indexOf(s)) && (e = a), function (t, e, r) { for (var n, i, a = [], s = 0, o = 0; o < e; o++) { o % 4 && (n = r[t.charCodeAt(o - 1)] << o % 4 * 2, i = r[t.charCodeAt(o)] >>> 6 - o % 4 * 2, a[s >>> 2] |= (n | i) << 24 - s % 4 * 8, s++) } return h.create(a, s) }(t, e, n) }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" } }(), r.enc.Base64) }), i = e(function (t, e) { var s; t.exports = (s = n, function (d) { var t = s, e = t.lib, r = e.WordArray, n = e.Hasher, i = t.algo, S = []; !function () { for (var t = 0; t < 64; t++)S[t] = 4294967296 * d.abs(d.sin(t + 1)) | 0 }(); var a = i.MD5 = n.extend({ _doReset: function () { this._hash = new r.init([1732584193, 4023233417, 2562383102, 271733878]) }, _doProcessBlock: function (t, e) { for (var r = 0; r < 16; r++) { var n = e + r, i = t[n]; t[n] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8) } var a = this._hash.words, s = t[e + 0], o = t[e + 1], h = t[e + 2], l = t[e + 3], d = t[e + 4], f = t[e + 5], c = t[e + 6], u = t[e + 7], _ = t[e + 8], p = t[e + 9], g = t[e + 10], v = t[e + 11], m = t[e + 12], w = t[e + 13], b = t[e + 14], k = t[e + 15], y = A(y = a[0], B = a[1], z = a[2], x = a[3], s, 7, S[0]), x = A(x, y, B, z, o, 12, S[1]), z = A(z, x, y, B, h, 17, S[2]), B = A(B, z, x, y, l, 22, S[3]); y = A(y, B, z, x, d, 7, S[4]), x = A(x, y, B, z, f, 12, S[5]), z = A(z, x, y, B, c, 17, S[6]), B = A(B, z, x, y, u, 22, S[7]), y = A(y, B, z, x, _, 7, S[8]), x = A(x, y, B, z, p, 12, S[9]), z = A(z, x, y, B, g, 17, S[10]), B = A(B, z, x, y, v, 22, S[11]), y = A(y, B, z, x, m, 7, S[12]), x = A(x, y, B, z, w, 12, S[13]), z = A(z, x, y, B, b, 17, S[14]), y = C(y, B = A(B, z, x, y, k, 22, S[15]), z, x, o, 5, S[16]), x = C(x, y, B, z, c, 9, S[17]), z = C(z, x, y, B, v, 14, S[18]), B = C(B, z, x, y, s, 20, S[19]), y = C(y, B, z, x, f, 5, S[20]), x = C(x, y, B, z, g, 9, S[21]), z = C(z, x, y, B, k, 14, S[22]), B = C(B, z, x, y, d, 20, S[23]), y = C(y, B, z, x, p, 5, S[24]), x = C(x, y, B, z, b, 9, S[25]), z = C(z, x, y, B, l, 14, S[26]), B = C(B, z, x, y, _, 20, S[27]), y = C(y, B, z, x, w, 5, S[28]), x = C(x, y, B, z, h, 9, S[29]), z = C(z, x, y, B, u, 14, S[30]), y = E(y, B = C(B, z, x, y, m, 20, S[31]), z, x, f, 4, S[32]), x = E(x, y, B, z, _, 11, S[33]), z = E(z, x, y, B, v, 16, S[34]), B = E(B, z, x, y, b, 23, S[35]), y = E(y, B, z, x, o, 4, S[36]), x = E(x, y, B, z, d, 11, S[37]), z = E(z, x, y, B, u, 16, S[38]), B = E(B, z, x, y, g, 23, S[39]), y = E(y, B, z, x, w, 4, S[40]), x = E(x, y, B, z, s, 11, S[41]), z = E(z, x, y, B, l, 16, S[42]), B = E(B, z, x, y, c, 23, S[43]), y = E(y, B, z, x, p, 4, S[44]), x = E(x, y, B, z, m, 11, S[45]), z = E(z, x, y, B, k, 16, S[46]), y = D(y, B = E(B, z, x, y, h, 23, S[47]), z, x, s, 6, S[48]), x = D(x, y, B, z, u, 10, S[49]), z = D(z, x, y, B, b, 15, S[50]), B = D(B, z, x, y, f, 21, S[51]), y = D(y, B, z, x, m, 6, S[52]), x = D(x, y, B, z, l, 10, S[53]), z = D(z, x, y, B, g, 15, S[54]), B = D(B, z, x, y, o, 21, S[55]), y = D(y, B, z, x, _, 6, S[56]), x = D(x, y, B, z, k, 10, S[57]), z = D(z, x, y, B, c, 15, S[58]), B = D(B, z, x, y, w, 21, S[59]), y = D(y, B, z, x, d, 6, S[60]), x = D(x, y, B, z, v, 10, S[61]), z = D(z, x, y, B, h, 15, S[62]), B = D(B, z, x, y, p, 21, S[63]), a[0] = a[0] + y | 0, a[1] = a[1] + B | 0, a[2] = a[2] + z | 0, a[3] = a[3] + x | 0 }, _doFinalize: function () { var t = this._data, e = t.words, r = 8 * this._nDataBytes, n = 8 * t.sigBytes; e[n >>> 5] |= 128 << 24 - n % 32; var i = d.floor(r / 4294967296), a = r; e[15 + (64 + n >>> 9 << 4)] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8), e[14 + (64 + n >>> 9 << 4)] = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8), t.sigBytes = 4 * (e.length + 1), this._process(); for (var s = this._hash, o = s.words, h = 0; h < 4; h++) { var l = o[h]; o[h] = 16711935 & (l << 8 | l >>> 24) | 4278255360 & (l << 24 | l >>> 8) } return s }, clone: function () { var t = n.clone.call(this); return t._hash = this._hash.clone(), t } }); function A (t, e, r, n, i, a, s) { var o = t + (e & r | ~e & n) + i + s; return (o << a | o >>> 32 - a) + e } function C (t, e, r, n, i, a, s) { var o = t + (e & n | r & ~n) + i + s; return (o << a | o >>> 32 - a) + e } function E (t, e, r, n, i, a, s) { var o = t + (e ^ r ^ n) + i + s; return (o << a | o >>> 32 - a) + e } function D (t, e, r, n, i, a, s) { var o = t + (r ^ (e | ~n)) + i + s; return (o << a | o >>> 32 - a) + e } t.MD5 = n._createHelper(a), t.HmacMD5 = n._createHmacHelper(a) }(Math), s.MD5) }), a = e(function (t, e) { var s; t.exports = (s = n, function () { var t = s, e = t.lib, r = e.WordArray, n = e.Hasher, i = t.algo, f = [], a = i.SHA1 = n.extend({ _doReset: function () { this._hash = new r.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]) }, _doProcessBlock: function (t, e) { for (var r, n = this._hash.words, i = n[0], a = n[1], s = n[2], o = n[3], h = n[4], l = 0; l < 80; l++) { l < 16 ? f[l] = 0 | t[e + l] : (r = f[l - 3] ^ f[l - 8] ^ f[l - 14] ^ f[l - 16], f[l] = r << 1 | r >>> 31); var d = (i << 5 | i >>> 27) + h + f[l]; d += l < 20 ? 1518500249 + (a & s | ~a & o) : l < 40 ? 1859775393 + (a ^ s ^ o) : l < 60 ? (a & s | a & o | s & o) - 1894007588 : (a ^ s ^ o) - 899497514, h = o, o = s, s = a << 30 | a >>> 2, a = i, i = d } n[0] = n[0] + i | 0, n[1] = n[1] + a | 0, n[2] = n[2] + s | 0, n[3] = n[3] + o | 0, n[4] = n[4] + h | 0 }, _doFinalize: function () { var t = this._data, e = t.words, r = 8 * this._nDataBytes, n = 8 * t.sigBytes; return e[n >>> 5] |= 128 << 24 - n % 32, e[14 + (64 + n >>> 9 << 4)] = Math.floor(r / 4294967296), e[15 + (64 + n >>> 9 << 4)] = r, t.sigBytes = 4 * e.length, this._process(), this._hash }, clone: function () { var t = n.clone.call(this); return t._hash = this._hash.clone(), t } }); t.SHA1 = n._createHelper(a), t.HmacSHA1 = n._createHmacHelper(a) }(), s.SHA1) }), s = e(function (t, e) { var r; t.exports = (r = n, void function () { var t = r.lib.Base, l = r.enc.Utf8; r.algo.HMAC = t.extend({ init: function (t, e) { t = this._hasher = new t.init, "string" == typeof e && (e = l.parse(e)); var r = t.blockSize, n = 4 * r; e.sigBytes > n && (e = t.finalize(e)), e.clamp(); for (var i = this._oKey = e.clone(), a = this._iKey = e.clone(), s = i.words, o = a.words, h = 0; h < r; h++)s[h] ^= 1549556828, o[h] ^= 909522486; i.sigBytes = a.sigBytes = n, this.reset() }, reset: function () { var t = this._hasher; t.reset(), t.update(this._iKey) }, update: function (t) { return this._hasher.update(t), this }, finalize: function (t) { var e = this._hasher, r = e.finalize(t); return e.reset(), e.finalize(this._oKey.clone().concat(r)) } }) }()) }), o = e(function (t, e) { var s; t.exports = (s = n, function () { var t = s, e = t.lib, r = e.Base, d = e.WordArray, n = t.algo, i = n.MD5, a = n.EvpKDF = r.extend({ cfg: r.extend({ keySize: 4, hasher: i, iterations: 1 }), init: function (t) { this.cfg = this.cfg.extend(t) }, compute: function (t, e) { for (var r = this.cfg, n = r.hasher.create(), i = d.create(), a = i.words, s = r.keySize, o = r.iterations; a.length < s;) { h && n.update(h); var h = n.update(t).finalize(e); n.reset(); for (var l = 1; l < o; l++)h = n.finalize(h), n.reset(); i.concat(h) } return i.sigBytes = 4 * s, i } }); t.EvpKDF = function (t, e, r) { return a.create(r).compute(t, e) } }(), s.EvpKDF) }), h = e(function (t, e) { var k; t.exports = void ((k = n).lib.Cipher || function () { var t = k, e = t.lib, r = e.Base, h = e.WordArray, n = e.BufferedBlockAlgorithm, i = t.enc, a = (i.Utf8, i.Base64), s = t.algo.EvpKDF, o = e.Cipher = n.extend({ cfg: r.extend(), createEncryptor: function (t, e) { return this.create(this._ENC_XFORM_MODE, t, e) }, createDecryptor: function (t, e) { return this.create(this._DEC_XFORM_MODE, t, e) }, init: function (t, e, r) { this.cfg = this.cfg.extend(r), this._xformMode = t, this._key = e, this.reset() }, reset: function () { n.reset.call(this), this._doReset() }, process: function (t) { return this._append(t), this._process() }, finalize: function (t) { return t && this._append(t), this._doFinalize() }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: function (n) { return { encrypt: function (t, e, r) { return l(e).encrypt(n, t, e, r) }, decrypt: function (t, e, r) { return l(e).decrypt(n, t, e, r) } } } }); function l (t) { return "string" == typeof t ? b : m } e.StreamCipher = o.extend({ _doFinalize: function () { return this._process(!0) }, blockSize: 1 }); var d, f = t.mode = {}, c = e.BlockCipherMode = r.extend({ createEncryptor: function (t, e) { return this.Encryptor.create(t, e) }, createDecryptor: function (t, e) { return this.Decryptor.create(t, e) }, init: function (t, e) { this._cipher = t, this._iv = e } }), u = f.CBC = ((d = c.extend()).Encryptor = d.extend({ processBlock: function (t, e) { var r = this._cipher, n = r.blockSize; _.call(this, t, e, n), r.encryptBlock(t, e), this._prevBlock = t.slice(e, e + n) } }), d.Decryptor = d.extend({ processBlock: function (t, e) { var r = this._cipher, n = r.blockSize, i = t.slice(e, e + n); r.decryptBlock(t, e), _.call(this, t, e, n), this._prevBlock = i } }), d); function _ (t, e, r) { var n, i = this._iv; i ? (n = i, this._iv = void 0) : n = this._prevBlock; for (var a = 0; a < r; a++)t[e + a] ^= n[a] } var p = (t.pad = {}).Pkcs7 = { pad: function (t, e) { for (var r = 4 * e, n = r - t.sigBytes % r, i = n << 24 | n << 16 | n << 8 | n, a = [], s = 0; s < n; s += 4)a.push(i); var o = h.create(a, n); t.concat(o) }, unpad: function (t) { var e = 255 & t.words[t.sigBytes - 1 >>> 2]; t.sigBytes -= e } }, g = (e.BlockCipher = o.extend({ cfg: o.cfg.extend({ mode: u, padding: p }), reset: function () { o.reset.call(this); var t, e = this.cfg, r = e.iv, n = e.mode; this._xformMode == this._ENC_XFORM_MODE ? t = n.createEncryptor : (t = n.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == t ? this._mode.init(this, r && r.words) : (this._mode = t.call(n, this, r && r.words), this._mode.__creator = t) }, _doProcessBlock: function (t, e) { this._mode.processBlock(t, e) }, _doFinalize: function () { var t, e = this.cfg.padding; return this._xformMode == this._ENC_XFORM_MODE ? (e.pad(this._data, this.blockSize), t = this._process(!0)) : (t = this._process(!0), e.unpad(t)), t }, blockSize: 4 }), e.CipherParams = r.extend({ init: function (t) { this.mixIn(t) }, toString: function (t) { return (t || this.formatter).stringify(this) } })), v = (t.format = {}).OpenSSL = { stringify: function (t) { var e = t.ciphertext, r = t.salt; return (r ? h.create([1398893684, 1701076831]).concat(r).concat(e) : e).toString(a) }, parse: function (t) { var e, r = a.parse(t), n = r.words; return 1398893684 == n[0] && 1701076831 == n[1] && (e = h.create(n.slice(2, 4)), n.splice(0, 4), r.sigBytes -= 16), g.create({ ciphertext: r, salt: e }) } }, m = e.SerializableCipher = r.extend({ cfg: r.extend({ format: v }), encrypt: function (t, e, r, n) { n = this.cfg.extend(n); var i = t.createEncryptor(r, n), a = i.finalize(e), s = i.cfg; return g.create({ ciphertext: a, key: r, iv: s.iv, algorithm: t, mode: s.mode, padding: s.padding, blockSize: t.blockSize, formatter: n.format }) }, decrypt: function (t, e, r, n) { return n = this.cfg.extend(n), e = this._parse(e, n.format), t.createDecryptor(r, n).finalize(e.ciphertext) }, _parse: function (t, e) { return "string" == typeof t ? e.parse(t, this) : t } }), w = (t.kdf = {}).OpenSSL = { execute: function (t, e, r, n) { n = n || h.random(8); var i = s.create({ keySize: e + r }).compute(t, n), a = h.create(i.words.slice(e), 4 * r); return i.sigBytes = 4 * e, g.create({ key: i, iv: a, salt: n }) } }, b = e.PasswordBasedCipher = m.extend({ cfg: m.cfg.extend({ kdf: w }), encrypt: function (t, e, r, n) { var i = (n = this.cfg.extend(n)).kdf.execute(r, t.keySize, t.ivSize); n.iv = i.iv; var a = m.encrypt.call(this, t, e, i.key, n); return a.mixIn(i), a }, decrypt: function (t, e, r, n) { n = this.cfg.extend(n), e = this._parse(e, n.format); var i = n.kdf.execute(r, t.keySize, t.ivSize, e.salt); return n.iv = i.iv, m.decrypt.call(this, t, e, i.key, n) } }) }()) }), d = e(function (t, e) { var i; t.exports = (i = n, function () { var t = i, e = t.lib.BlockCipher, r = t.algo, l = [], d = [], f = [], c = [], u = [], _ = [], p = [], g = [], v = [], m = []; !function () { for (var t = [], e = 0; e < 256; e++)t[e] = e < 128 ? e << 1 : e << 1 ^ 283; for (var r = 0, n = 0, e = 0; e < 256; e++) { var i = (i = n ^ n << 1 ^ n << 2 ^ n << 3 ^ n << 4) >>> 8 ^ 255 & i ^ 99; l[r] = i; var a = t[d[i] = r], s = t[a], o = t[s], h = 257 * t[i] ^ 16843008 * i; f[r] = h << 24 | h >>> 8, c[r] = h << 16 | h >>> 16, u[r] = h << 8 | h >>> 24, _[r] = h, h = 16843009 * o ^ 65537 * s ^ 257 * a ^ 16843008 * r, p[i] = h << 24 | h >>> 8, g[i] = h << 16 | h >>> 16, v[i] = h << 8 | h >>> 24, m[i] = h, r ? (r = a ^ t[t[t[o ^ a]]], n ^= t[t[n]]) : r = n = 1 } }(); var w = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], n = r.AES = e.extend({ _doReset: function () { if (!this._nRounds || this._keyPriorReset !== this._key) { for (var t = this._keyPriorReset = this._key, e = t.words, r = t.sigBytes / 4, n = 4 * (1 + (this._nRounds = 6 + r)), i = this._keySchedule = [], a = 0; a < n; a++)a < r ? i[a] = e[a] : (h = i[a - 1], a % r ? 6 < r && a % r == 4 && (h = l[h >>> 24] << 24 | l[h >>> 16 & 255] << 16 | l[h >>> 8 & 255] << 8 | l[255 & h]) : (h = l[(h = h << 8 | h >>> 24) >>> 24] << 24 | l[h >>> 16 & 255] << 16 | l[h >>> 8 & 255] << 8 | l[255 & h], h ^= w[a / r | 0] << 24), i[a] = i[a - r] ^ h); for (var s = this._invKeySchedule = [], o = 0; o < n; o++) { var h, a = n - o; h = o % 4 ? i[a] : i[a - 4], s[o] = o < 4 || a <= 4 ? h : p[l[h >>> 24]] ^ g[l[h >>> 16 & 255]] ^ v[l[h >>> 8 & 255]] ^ m[l[255 & h]] } } }, encryptBlock: function (t, e) { this._doCryptBlock(t, e, this._keySchedule, f, c, u, _, l) }, decryptBlock: function (t, e) { var r = t[e + 1]; t[e + 1] = t[e + 3], t[e + 3] = r, this._doCryptBlock(t, e, this._invKeySchedule, p, g, v, m, d), r = t[e + 1], t[e + 1] = t[e + 3], t[e + 3] = r }, _doCryptBlock: function (t, e, r, n, i, a, s, o) { for (var h = this._nRounds, l = t[e] ^ r[0], d = t[e + 1] ^ r[1], f = t[e + 2] ^ r[2], c = t[e + 3] ^ r[3], u = 4, _ = 1; _ < h; _++)var p = n[l >>> 24] ^ i[d >>> 16 & 255] ^ a[f >>> 8 & 255] ^ s[255 & c] ^ r[u++], g = n[d >>> 24] ^ i[f >>> 16 & 255] ^ a[c >>> 8 & 255] ^ s[255 & l] ^ r[u++], v = n[f >>> 24] ^ i[c >>> 16 & 255] ^ a[l >>> 8 & 255] ^ s[255 & d] ^ r[u++], m = n[c >>> 24] ^ i[l >>> 16 & 255] ^ a[d >>> 8 & 255] ^ s[255 & f] ^ r[u++], l = p, d = g, f = v, c = m; p = (o[l >>> 24] << 24 | o[d >>> 16 & 255] << 16 | o[f >>> 8 & 255] << 8 | o[255 & c]) ^ r[u++], g = (o[d >>> 24] << 24 | o[f >>> 16 & 255] << 16 | o[c >>> 8 & 255] << 8 | o[255 & l]) ^ r[u++], v = (o[f >>> 24] << 24 | o[c >>> 16 & 255] << 16 | o[l >>> 8 & 255] << 8 | o[255 & d]) ^ r[u++], m = (o[c >>> 24] << 24 | o[l >>> 16 & 255] << 16 | o[d >>> 8 & 255] << 8 | o[255 & f]) ^ r[u++], t[e] = p, t[e + 1] = g, t[e + 2] = v, t[e + 3] = m }, keySize: 8 }); t.AES = e._createHelper(n) }(), i.AES) }), f = e(function (t, e) { var r; t.exports = ((r = n).mode.ECB = function () { var t = r.lib.BlockCipherMode.extend(); return t.Encryptor = t.extend({ processBlock: function (t, e) { this._cipher.encryptBlock(t, e) } }), t.Decryptor = t.extend({ processBlock: function (t, e) { this._cipher.decryptBlock(t, e) } }), t }(), r.mode.ECB) }), N = e(function (t, e) { var r = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array; e.assign = function (t) { for (var e, r, n = Array.prototype.slice.call(arguments, 1); n.length;) { var i = n.shift(); if (i) { if ("object" != typeof i) throw new TypeError(i + "must be non-object"); for (var a in i) e = i, r = a, Object.prototype.hasOwnProperty.call(e, r) && (t[a] = i[a]) } } return t }, e.shrinkBuf = function (t, e) { return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t) }; var n = { arraySet: function (t, e, r, n, i) { if (e.subarray && t.subarray) t.set(e.subarray(r, r + n), i); else for (var a = 0; a < n; a++)t[i + a] = e[r + a] }, flattenChunks: function (t) { for (var e, r, n, i = 0, a = 0, s = t.length; a < s; a++)i += t[a].length; for (n = new Uint8Array(i), a = e = 0, s = t.length; a < s; a++)r = t[a], n.set(r, e), e += r.length; return n } }, i = { arraySet: function (t, e, r, n, i) { for (var a = 0; a < n; a++)t[i + a] = e[r + a] }, flattenChunks: function (t) { return [].concat.apply([], t) } }; e.setTyped = function (t) { t ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, n)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, i)) }, e.setTyped(r) }), c = N.assign, u = N.shrinkBuf, _ = N.setTyped, p = N.Buf8, g = N.Buf16, v = N.Buf32, m = 4, w = 0, b = 1, k = 2; function y (t) { for (var e = t.length; 0 <= --e;)t[e] = 0 } var x = 0, z = 1, B = 2, S = 3, A = 258, C = 29, E = 256, D = E + 1 + C, R = 30, O = 19, Z = 2 * D + 1, H = 15, F = 16, M = 7, I = 256, U = 16, T = 17, L = 18, K = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], j = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], P = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], X = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], W = 512, Y = new Array(2 * (D + 2)); y(Y); var G = new Array(2 * R); y(G); var q = new Array(W); y(q); var J = new Array(A - S + 1); y(J); var $ = new Array(C); y($); var Q, V, tt, et = new Array(R); function rt (t, e, r, n, i) { this.static_tree = t, this.extra_bits = e, this.extra_base = r, this.elems = n, this.max_length = i, this.has_stree = t && t.length } function nt (t, e) { this.dyn_tree = t, this.max_code = 0, this.stat_desc = e } function it (t) { return t < 256 ? q[t] : q[256 + (t >>> 7)] } function at (t, e) { t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255 } function st (t, e, r) { t.bi_valid > F - r ? (t.bi_buf |= e << t.bi_valid & 65535, at(t, t.bi_buf), t.bi_buf = e >> F - t.bi_valid, t.bi_valid += r - F) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += r) } function ot (t, e, r) { st(t, r[2 * e], r[2 * e + 1]) } function ht (t, e) { for (var r = 0; r |= 1 & t, t >>>= 1, r <<= 1, 0 < --e;); return r >>> 1 } function lt (t) { 16 === t.bi_valid ? (at(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : 8 <= t.bi_valid && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8) } function dt (t, e) { for (var r, n, i, a, s, o = e.dyn_tree, h = e.max_code, l = e.stat_desc.static_tree, d = e.stat_desc.has_stree, f = e.stat_desc.extra_bits, c = e.stat_desc.extra_base, u = e.stat_desc.max_length, _ = 0, p = 0; p <= H; p++)t.bl_count[p] = 0; for (o[2 * t.heap[t.heap_max] + 1] = 0, r = t.heap_max + 1; r < Z; r++)u < (p = o[2 * o[2 * (n = t.heap[r]) + 1] + 1] + 1) && (p = u, _++), o[2 * n + 1] = p, h < n || (t.bl_count[p]++, a = 0, c <= n && (a = f[n - c]), s = o[2 * n], t.opt_len += s * (p + a), d && (t.static_len += s * (l[2 * n + 1] + a))); if (0 !== _) { do { for (p = u - 1; 0 === t.bl_count[p];)p--; t.bl_count[p]--, t.bl_count[p + 1] += 2, t.bl_count[u]--, _ -= 2 } while (0 < _); for (p = u; 0 !== p; p--)for (n = t.bl_count[p]; 0 !== n;)h < (i = t.heap[--r]) || (o[2 * i + 1] !== p && (t.opt_len += (p - o[2 * i + 1]) * o[2 * i], o[2 * i + 1] = p), n--) } } function ft (t, e, r) { for (var n, i = new Array(H + 1), a = 0, s = 1; s <= H; s++)i[s] = a = a + r[s - 1] << 1; for (n = 0; n <= e; n++) { var o = t[2 * n + 1]; 0 !== o && (t[2 * n] = ht(i[o]++, o)) } } function ct () { for (var t, e, r, n = new Array(H + 1), i = 0, a = 0; a < C - 1; a++)for ($[a] = i, t = 0; t < 1 << K[a]; t++)J[i++] = a; for (J[i - 1] = a, a = r = 0; a < 16; a++)for (et[a] = r, t = 0; t < 1 << j[a]; t++)q[r++] = a; for (r >>= 7; a < R; a++)for (et[a] = r << 7, t = 0; t < 1 << j[a] - 7; t++)q[256 + r++] = a; for (e = 0; e <= H; e++)n[e] = 0; for (t = 0; t <= 143;)Y[2 * t + 1] = 8, t++, n[8]++; for (; t <= 255;)Y[2 * t + 1] = 9, t++, n[9]++; for (; t <= 279;)Y[2 * t + 1] = 7, t++, n[7]++; for (; t <= 287;)Y[2 * t + 1] = 8, t++, n[8]++; for (ft(Y, D + 1, n), t = 0; t < R; t++)G[2 * t + 1] = 5, G[2 * t] = ht(t, 5); Q = new rt(Y, K, E + 1, D, H), V = new rt(G, j, 0, R, H), tt = new rt(new Array(0), P, 0, O, M) } function ut (t) { for (var e = 0; e < D; e++)t.dyn_ltree[2 * e] = 0; for (e = 0; e < R; e++)t.dyn_dtree[2 * e] = 0; for (e = 0; e < O; e++)t.bl_tree[2 * e] = 0; t.dyn_ltree[2 * I] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0 } function _t (t) { 8 < t.bi_valid ? at(t, t.bi_buf) : 0 < t.bi_valid && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0 } function pt (t, e, r, n) { _t(t), n && (at(t, r), at(t, ~r)), N.arraySet(t.pending_buf, t.window, e, r, t.pending), t.pending += r } function gt (t, e, r, n) { var i = 2 * e, a = 2 * r; return t[i] < t[a] || t[i] === t[a] && n[e] <= n[r] } function vt (t, e, r) { for (var n = t.heap[r], i = r << 1; i <= t.heap_len && (i < t.heap_len && gt(e, t.heap[i + 1], t.heap[i], t.depth) && i++, !gt(e, n, t.heap[i], t.depth));)t.heap[r] = t.heap[i], r = i, i <<= 1; t.heap[r] = n } function mt (t, e, r) { var n, i, a, s, o = 0; if (0 !== t.last_lit) for (; n = t.pending_buf[t.d_buf + 2 * o] << 8 | t.pending_buf[t.d_buf + 2 * o + 1], i = t.pending_buf[t.l_buf + o], o++, 0 === n ? ot(t, i, e) : (ot(t, (a = J[i]) + E + 1, e), 0 !== (s = K[a]) && st(t, i -= $[a], s), ot(t, a = it(--n), r), 0 !== (s = j[a]) && st(t, n -= et[a], s)), o < t.last_lit;); ot(t, I, e) } function wt (t, e) { var r, n, i, a = e.dyn_tree, s = e.stat_desc.static_tree, o = e.stat_desc.has_stree, h = e.stat_desc.elems, l = -1; for (t.heap_len = 0, t.heap_max = Z, r = 0; r < h; r++)0 !== a[2 * r] ? (t.heap[++t.heap_len] = l = r, t.depth[r] = 0) : a[2 * r + 1] = 0; for (; t.heap_len < 2;)a[2 * (i = t.heap[++t.heap_len] = l < 2 ? ++l : 0)] = 1, t.depth[i] = 0, t.opt_len--, o && (t.static_len -= s[2 * i + 1]); for (e.max_code = l, r = t.heap_len >> 1; 1 <= r; r--)vt(t, a, r); for (i = h; r = t.heap[1], t.heap[1] = t.heap[t.heap_len--], vt(t, a, 1), n = t.heap[1], t.heap[--t.heap_max] = r, t.heap[--t.heap_max] = n, a[2 * i] = a[2 * r] + a[2 * n], t.depth[i] = (t.depth[r] >= t.depth[n] ? t.depth[r] : t.depth[n]) + 1, a[2 * r + 1] = a[2 * n + 1] = i, t.heap[1] = i++, vt(t, a, 1), 2 <= t.heap_len;); t.heap[--t.heap_max] = t.heap[1], dt(t, e), ft(a, l, t.bl_count) } function bt (t, e, r) { var n, i, a = -1, s = e[1], o = 0, h = 7, l = 4; for (0 === s && (h = 138, l = 3), e[2 * (r + 1) + 1] = 65535, n = 0; n <= r; n++)i = s, s = e[2 * (n + 1) + 1], ++o < h && i === s || (o < l ? t.bl_tree[2 * i] += o : 0 !== i ? (i !== a && t.bl_tree[2 * i]++, t.bl_tree[2 * U]++) : o <= 10 ? t.bl_tree[2 * T]++ : t.bl_tree[2 * L]++, a = i, l = (o = 0) === s ? (h = 138, 3) : i === s ? (h = 6, 3) : (h = 7, 4)) } function kt (t, e, r) { var n, i, a = -1, s = e[1], o = 0, h = 7, l = 4; for (0 === s && (h = 138, l = 3), n = 0; n <= r; n++)if (i = s, s = e[2 * (n + 1) + 1], !(++o < h && i === s)) { if (o < l) for (; ot(t, i, t.bl_tree), 0 != --o;); else 0 !== i ? (i !== a && (ot(t, i, t.bl_tree), o--), ot(t, U, t.bl_tree), st(t, o - 3, 2)) : o <= 10 ? (ot(t, T, t.bl_tree), st(t, o - 3, 3)) : (ot(t, L, t.bl_tree), st(t, o - 11, 7)); a = i, l = (o = 0) === s ? (h = 138, 3) : i === s ? (h = 6, 3) : (h = 7, 4) } } function yt (t) { var e; for (bt(t, t.dyn_ltree, t.l_desc.max_code), bt(t, t.dyn_dtree, t.d_desc.max_code), wt(t, t.bl_desc), e = O - 1; 3 <= e && 0 === t.bl_tree[2 * X[e] + 1]; e--); return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e } function xt (t, e, r, n) { var i; for (st(t, e - 257, 5), st(t, r - 1, 5), st(t, n - 4, 4), i = 0; i < n; i++)st(t, t.bl_tree[2 * X[i] + 1], 3); kt(t, t.dyn_ltree, e - 1), kt(t, t.dyn_dtree, r - 1) } function zt (t) { for (var e = 4093624447, r = 0; r <= 31; r++, e >>>= 1)if (1 & e && 0 !== t.dyn_ltree[2 * r]) return w; if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return b; for (r = 32; r < E; r++)if (0 !== t.dyn_ltree[2 * r]) return b; return w } y(et); var Bt = !1; function St (t) { Bt || (ct(), Bt = !0), t.l_desc = new nt(t.dyn_ltree, Q), t.d_desc = new nt(t.dyn_dtree, V), t.bl_desc = new nt(t.bl_tree, tt), t.bi_buf = 0, t.bi_valid = 0, ut(t) } function At (t, e, r, n) { st(t, (x << 1) + (n ? 1 : 0), 3), pt(t, e, r, !0) } function Ct (t) { st(t, z << 1, 3), ot(t, I, Y), lt(t) } function Et (t, e, r, n) { var i, a, s = 0; 0 < t.level ? (t.strm.data_type === k && (t.strm.data_type = zt(t)), wt(t, t.l_desc), wt(t, t.d_desc), s = yt(t), i = t.opt_len + 3 + 7 >>> 3, (a = t.static_len + 3 + 7 >>> 3) <= i && (i = a)) : i = a = r + 5, r + 4 <= i && -1 !== e ? At(t, e, r, n) : t.strategy === m || a === i ? (st(t, (z << 1) + (n ? 1 : 0), 3), mt(t, Y, G)) : (st(t, (B << 1) + (n ? 1 : 0), 3), xt(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, s + 1), mt(t, t.dyn_ltree, t.dyn_dtree)), ut(t), n && _t(t) } function Dt (t, e, r) { return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & r, t.last_lit++, 0 === e ? t.dyn_ltree[2 * r]++ : (t.matches++, e--, t.dyn_ltree[2 * (J[r] + E + 1)]++, t.dyn_dtree[2 * it(e)]++), t.last_lit === t.lit_bufsize - 1 } var Rt = St, Ot = At, Zt = Et, Nt = Dt, Ht = Ct, Ft = { _tr_init: St, _tr_stored_block: At, _tr_flush_block: Et, _tr_tally: Dt, _tr_align: Ct }; function Mt (t, e, r, n) { for (var i = 65535 & t | 0, a = t >>> 16 & 65535 | 0, s = 0; 0 !== r;) { for (r -= s = 2e3 < r ? 2e3 : r; a = a + (i = i + e[n++] | 0) | 0, --s;); i %= 65521, a %= 65521 } return i | a << 16 | 0 } var It = Mt; function Ut () { for (var t, e = [], r = 0; r < 256; r++) { t = r; for (var n = 0; n < 8; n++)t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1; e[r] = t } return e } var Tt = Ut(); function Lt (t, e, r, n) { var i = Tt, a = n + r; t ^= -1; for (var s = n; s < a; s++)t = t >>> 8 ^ i[255 & (t ^ e[s])]; return -1 ^ t } var Kt, jt = Lt, Pt = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }, Xt = 0, Wt = 1, Yt = 3, Gt = 4, qt = 5, Jt = 0, $t = 1, Qt = -2, Vt = -3, te = -5, ee = -1, re = 1, ne = 2, ie = 3, ae = 4, se = 0, oe = 2, he = 8, le = 9, de = 15, fe = 8, ce = 29, ue = 256, _e = ue + 1 + ce, pe = 30, ge = 19, ve = 2 * _e + 1, me = 15, we = 3, be = 258, ke = be + we + 1, ye = 32, xe = 42, ze = 69, Be = 73, Se = 91, Ae = 103, Ce = 113, Ee = 666, De = 1, Re = 2, Oe = 3, Ze = 4, Ne = 3; function He (t, e) { return t.msg = Pt[e], e } function Fe (t) { return (t << 1) - (4 < t ? 9 : 0) } function Me (t) { for (var e = t.length; 0 <= --e;)t[e] = 0 } function Ie (t) { var e = t.state, r = e.pending; r > t.avail_out && (r = t.avail_out), 0 !== r && (N.arraySet(t.output, e.pending_buf, e.pending_out, r, t.next_out), t.next_out += r, e.pending_out += r, t.total_out += r, t.avail_out -= r, e.pending -= r, 0 === e.pending && (e.pending_out = 0)) } function Ue (t, e) { Ft._tr_flush_block(t, 0 <= t.block_start ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, Ie(t.strm) } function Te (t, e) { t.pending_buf[t.pending++] = e } function Le (t, e) { t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e } function Ke (t, e, r, n) { var i = t.avail_in; return n < i && (i = n), 0 === i ? 0 : (t.avail_in -= i, N.arraySet(e, t.input, t.next_in, i, r), 1 === t.state.wrap ? t.adler = It(t.adler, e, i, r) : 2 === t.state.wrap && (t.adler = jt(t.adler, e, i, r)), t.next_in += i, t.total_in += i, i) } function je (t, e) { var r, n, i = t.max_chain_length, a = t.strstart, s = t.prev_length, o = t.nice_match, h = t.strstart > t.w_size - ke ? t.strstart - (t.w_size - ke) : 0, l = t.window, d = t.w_mask, f = t.prev, c = t.strstart + be, u = l[a + s - 1], _ = l[a + s]; t.prev_length >= t.good_match && (i >>= 2), o > t.lookahead && (o = t.lookahead); do { if (l[(r = e) + s] === _ && l[r + s - 1] === u && l[r] === l[a] && l[++r] === l[a + 1]) { a += 2, r++; do { } while (l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && a < c); if (n = be - (c - a), a = c - be, s < n) { if (t.match_start = e, o <= (s = n)) break; u = l[a + s - 1], _ = l[a + s] } } } while ((e = f[e & d]) > h && 0 != --i); return s <= t.lookahead ? s : t.lookahead } function Pe (t) { var e, r, n, i, a, s = t.w_size; do { if (i = t.window_size - t.lookahead - t.strstart, t.strstart >= s + (s - ke)) { for (N.arraySet(t.window, t.window, s, s, 0), t.match_start -= s, t.strstart -= s, t.block_start -= s, e = r = t.hash_size; n = t.head[--e], t.head[e] = s <= n ? n - s : 0, --r;); for (e = r = s; n = t.prev[--e], t.prev[e] = s <= n ? n - s : 0, --r;); i += s } if (0 === t.strm.avail_in) break; if (r = Ke(t.strm, t.window, t.strstart + t.lookahead, i), t.lookahead += r, t.lookahead + t.insert >= we) for (a = t.strstart - t.insert, t.ins_h = t.window[a], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[a + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[a + we - 1]) & t.hash_mask, t.prev[a & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = a, a++, t.insert--, !(t.lookahead + t.insert < we));); } while (t.lookahead < ke && 0 !== t.strm.avail_in) } function Xe (t, e) { var r = 65535; for (r > t.pending_buf_size - 5 && (r = t.pending_buf_size - 5); ;) { if (t.lookahead <= 1) { if (Pe(t), 0 === t.lookahead && e === Xt) return De; if (0 === t.lookahead) break } t.strstart += t.lookahead, t.lookahead = 0; var n = t.block_start + r; if ((0 === t.strstart || t.strstart >= n) && (t.lookahead = t.strstart - n, t.strstart = n, Ue(t, !1), 0 === t.strm.avail_out)) return De; if (t.strstart - t.block_start >= t.w_size - ke && (Ue(t, !1), 0 === t.strm.avail_out)) return De } return t.insert = 0, e === Gt ? (Ue(t, !0), 0 === t.strm.avail_out ? Oe : Ze) : (t.strstart > t.block_start && (Ue(t, !1), t.strm.avail_out), De) } function We (t, e) { for (var r, n; ;) { if (t.lookahead < ke) { if (Pe(t), t.lookahead < ke && e === Xt) return De; if (0 === t.lookahead) break } if (r = 0, t.lookahead >= we && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + we - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== r && t.strstart - r <= t.w_size - ke && (t.match_length = je(t, r)), t.match_length >= we) if (n = Ft._tr_tally(t, t.strstart - t.match_start, t.match_length - we), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= we) { for (t.match_length--; t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + we - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart, 0 != --t.match_length;); t.strstart++ } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask; else n = Ft._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++; if (n && (Ue(t, !1), 0 === t.strm.avail_out)) return De } return t.insert = t.strstart < we - 1 ? t.strstart : we - 1, e === Gt ? (Ue(t, !0), 0 === t.strm.avail_out ? Oe : Ze) : t.last_lit && (Ue(t, !1), 0 === t.strm.avail_out) ? De : Re } function Ye (t, e) { for (var r, n, i; ;) { if (t.lookahead < ke) { if (Pe(t), t.lookahead < ke && e === Xt) return De; if (0 === t.lookahead) break } if (r = 0, t.lookahead >= we && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + we - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = we - 1, 0 !== r && t.prev_length < t.max_lazy_match && t.strstart - r <= t.w_size - ke && (t.match_length = je(t, r), t.match_length <= 5 && (t.strategy === re || t.match_length === we && 4096 < t.strstart - t.match_start) && (t.match_length = we - 1)), t.prev_length >= we && t.match_length <= t.prev_length) { for (i = t.strstart + t.lookahead - we, n = Ft._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - we), t.lookahead -= t.prev_length - 1, t.prev_length -= 2; ++t.strstart <= i && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + we - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 != --t.prev_length;); if (t.match_available = 0, t.match_length = we - 1, t.strstart++, n && (Ue(t, !1), 0 === t.strm.avail_out)) return De } else if (t.match_available) { if ((n = Ft._tr_tally(t, 0, t.window[t.strstart - 1])) && Ue(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return De } else t.match_available = 1, t.strstart++, t.lookahead-- } return t.match_available && (n = Ft._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < we - 1 ? t.strstart : we - 1, e === Gt ? (Ue(t, !0), 0 === t.strm.avail_out ? Oe : Ze) : t.last_lit && (Ue(t, !1), 0 === t.strm.avail_out) ? De : Re } function Ge (t, e) { for (var r, n, i, a, s = t.window; ;) { if (t.lookahead <= be) { if (Pe(t), t.lookahead <= be && e === Xt) return De; if (0 === t.lookahead) break } if (t.match_length = 0, t.lookahead >= we && 0 < t.strstart && (n = s[i = t.strstart - 1]) === s[++i] && n === s[++i] && n === s[++i]) { a = t.strstart + be; do { } while (n === s[++i] && n === s[++i] && n === s[++i] && n === s[++i] && n === s[++i] && n === s[++i] && n === s[++i] && n === s[++i] && i < a); t.match_length = be - (a - i), t.match_length > t.lookahead && (t.match_length = t.lookahead) } if (t.match_length >= we ? (r = Ft._tr_tally(t, 1, t.match_length - we), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (r = Ft._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), r && (Ue(t, !1), 0 === t.strm.avail_out)) return De } return t.insert = 0, e === Gt ? (Ue(t, !0), 0 === t.strm.avail_out ? Oe : Ze) : t.last_lit && (Ue(t, !1), 0 === t.strm.avail_out) ? De : Re } function qe (t, e) { for (var r; ;) { if (0 === t.lookahead && (Pe(t), 0 === t.lookahead)) { if (e === Xt) return De; break } if (t.match_length = 0, r = Ft._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, r && (Ue(t, !1), 0 === t.strm.avail_out)) return De } return t.insert = 0, e === Gt ? (Ue(t, !0), 0 === t.strm.avail_out ? Oe : Ze) : t.last_lit && (Ue(t, !1), 0 === t.strm.avail_out) ? De : Re } function Je (t, e, r, n, i) { this.good_length = t, this.max_lazy = e, this.nice_length = r, this.max_chain = n, this.func = i } function $e (t) { t.window_size = 2 * t.w_size, Me(t.head), t.max_lazy_match = Kt[t.level].max_lazy, t.good_match = Kt[t.level].good_length, t.nice_match = Kt[t.level].nice_length, t.max_chain_length = Kt[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = we - 1, t.match_available = 0, t.ins_h = 0 } function Qe () { this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = he, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new N.Buf16(2 * ve), this.dyn_dtree = new N.Buf16(2 * (2 * pe + 1)), this.bl_tree = new N.Buf16(2 * (2 * ge + 1)), Me(this.dyn_ltree), Me(this.dyn_dtree), Me(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new N.Buf16(me + 1), this.heap = new N.Buf16(2 * _e + 1), Me(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new N.Buf16(2 * _e + 1), Me(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0 } function Ve (t) { var e; return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = oe, (e = t.state).pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? xe : Ce, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = Xt, Ft._tr_init(e), Jt) : He(t, Qt) } function tr (t) { var e = Ve(t); return e === Jt && $e(t.state), e } function er (t, e) { return !t || !t.state || 2 !== t.state.wrap ? Qt : (t.state.gzhead = e, Jt) } function rr (t, e, r, n, i, a) { if (!t) return Qt; var s = 1; if (e === ee && (e = 6), n < 0 ? (s = 0, n = -n) : 15 < n && (s = 2, n -= 16), i < 1 || le < i || r !== he || n < 8 || 15 < n || e < 0 || 9 < e || a < 0 || ae < a) return He(t, Qt); 8 === n && (n = 9); var o = new Qe; return (t.state = o).strm = t, o.wrap = s, o.gzhead = null, o.w_bits = n, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = i + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + we - 1) / we), o.window = new N.Buf8(2 * o.w_size), o.head = new N.Buf16(o.hash_size), o.prev = new N.Buf16(o.w_size), o.lit_bufsize = 1 << i + 6, o.pending_buf_size = 4 * o.lit_bufsize, o.pending_buf = new N.Buf8(o.pending_buf_size), o.d_buf = +o.lit_bufsize, o.l_buf = 3 * o.lit_bufsize, o.level = e, o.strategy = a, o.method = r, tr(t) } function nr (t, e) { return rr(t, e, he, de, fe, se) } function ir (t, e) { var r, n, i, a, s; if (!t || !t.state || qt < e || e < 0) return t ? He(t, Qt) : Qt; if (n = t.state, !t.output || !t.input && 0 !== t.avail_in || n.status === Ee && e !== Gt) return He(t, 0 === t.avail_out ? te : Qt); if (n.strm = t, r = n.last_flush, n.last_flush = e, n.status === xe && (2 === n.wrap ? (t.adler = 0, Te(n, 31), Te(n, 139), Te(n, 8), n.gzhead ? (Te(n, (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)), Te(n, 255 & n.gzhead.time), Te(n, n.gzhead.time >> 8 & 255), Te(n, n.gzhead.time >> 16 & 255), Te(n, n.gzhead.time >> 24 & 255), Te(n, 9 === n.level ? 2 : n.strategy >= ne || n.level < 2 ? 4 : 0), Te(n, 255 & n.gzhead.os), n.gzhead.extra && n.gzhead.extra.length && (Te(n, 255 & n.gzhead.extra.length), Te(n, n.gzhead.extra.length >> 8 & 255)), n.gzhead.hcrc && (t.adler = jt(t.adler, n.pending_buf, n.pending, 0)), n.gzindex = 0, n.status = ze) : (Te(n, 0), Te(n, 0), Te(n, 0), Te(n, 0), Te(n, 0), Te(n, 9 === n.level ? 2 : n.strategy >= ne || n.level < 2 ? 4 : 0), Te(n, Ne), n.status = Ce)) : (s = he + (n.w_bits - 8 << 4) << 8, s |= (n.strategy >= ne || n.level < 2 ? 0 : n.level < 6 ? 1 : 6 === n.level ? 2 : 3) << 6, 0 !== n.strstart && (s |= ye), s += 31 - s % 31, n.status = Ce, Le(n, s), 0 !== n.strstart && (Le(n, t.adler >>> 16), Le(n, 65535 & t.adler)), t.adler = 1)), n.status === ze) if (n.gzhead.extra) { for (i = n.pending; n.gzindex < (65535 & n.gzhead.extra.length) && (n.pending !== n.pending_buf_size || (n.gzhead.hcrc && n.pending > i && (t.adler = jt(t.adler, n.pending_buf, n.pending - i, i)), Ie(t), i = n.pending, n.pending !== n.pending_buf_size));)Te(n, 255 & n.gzhead.extra[n.gzindex]), n.gzindex++; n.gzhead.hcrc && n.pending > i && (t.adler = jt(t.adler, n.pending_buf, n.pending - i, i)), n.gzindex === n.gzhead.extra.length && (n.gzindex = 0, n.status = Be) } else n.status = Be; if (n.status === Be) if (n.gzhead.name) { i = n.pending; do { if (n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > i && (t.adler = jt(t.adler, n.pending_buf, n.pending - i, i)), Ie(t), i = n.pending, n.pending === n.pending_buf_size)) { a = 1; break } a = n.gzindex < n.gzhead.name.length ? 255 & n.gzhead.name.charCodeAt(n.gzindex++) : 0, Te(n, a) } while (0 !== a); n.gzhead.hcrc && n.pending > i && (t.adler = jt(t.adler, n.pending_buf, n.pending - i, i)), 0 === a && (n.gzindex = 0, n.status = Se) } else n.status = Se; if (n.status === Se) if (n.gzhead.comment) { i = n.pending; do { if (n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > i && (t.adler = jt(t.adler, n.pending_buf, n.pending - i, i)), Ie(t), i = n.pending, n.pending === n.pending_buf_size)) { a = 1; break } a = n.gzindex < n.gzhead.comment.length ? 255 & n.gzhead.comment.charCodeAt(n.gzindex++) : 0, Te(n, a) } while (0 !== a); n.gzhead.hcrc && n.pending > i && (t.adler = jt(t.adler, n.pending_buf, n.pending - i, i)), 0 === a && (n.status = Ae) } else n.status = Ae; if (n.status === Ae && (n.gzhead.hcrc ? (n.pending + 2 > n.pending_buf_size && Ie(t), n.pending + 2 <= n.pending_buf_size && (Te(n, 255 & t.adler), Te(n, t.adler >> 8 & 255), t.adler = 0, n.status = Ce)) : n.status = Ce), 0 !== n.pending) { if (Ie(t), 0 === t.avail_out) return n.last_flush = -1, Jt } else if (0 === t.avail_in && Fe(e) <= Fe(r) && e !== Gt) return He(t, te); if (n.status === Ee && 0 !== t.avail_in) return He(t, te); if (0 !== t.avail_in || 0 !== n.lookahead || e !== Xt && n.status !== Ee) { var o = n.strategy === ne ? qe(n, e) : n.strategy === ie ? Ge(n, e) : Kt[n.level].func(n, e); if (o !== Oe && o !== Ze || (n.status = Ee), o === De || o === Oe) return 0 === t.avail_out && (n.last_flush = -1), Jt; if (o === Re && (e === Wt ? Ft._tr_align(n) : e !== qt && (Ft._tr_stored_block(n, 0, 0, !1), e === Yt && (Me(n.head), 0 === n.lookahead && (n.strstart = 0, n.block_start = 0, n.insert = 0))), Ie(t), 0 === t.avail_out)) return n.last_flush = -1, Jt } return e !== Gt ? Jt : n.wrap <= 0 ? $t : (2 === n.wrap ? (Te(n, 255 & t.adler), Te(n, t.adler >> 8 & 255), Te(n, t.adler >> 16 & 255), Te(n, t.adler >> 24 & 255), Te(n, 255 & t.total_in), Te(n, t.total_in >> 8 & 255), Te(n, t.total_in >> 16 & 255), Te(n, t.total_in >> 24 & 255)) : (Le(n, t.adler >>> 16), Le(n, 65535 & t.adler)), Ie(t), 0 < n.wrap && (n.wrap = -n.wrap), 0 !== n.pending ? Jt : $t) } function ar (t) { var e; return t && t.state ? (e = t.state.status) !== xe && e !== ze && e !== Be && e !== Se && e !== Ae && e !== Ce && e !== Ee ? He(t, Qt) : (t.state = null, e === Ce ? He(t, Vt) : Jt) : Qt } function sr (t, e) { var r, n, i, a, s, o, h, l, d = e.length; if (!t || !t.state) return Qt; if (2 === (a = (r = t.state).wrap) || 1 === a && r.status !== xe || r.lookahead) return Qt; for (1 === a && (t.adler = It(t.adler, e, d, 0)), r.wrap = 0, d >= r.w_size && (0 === a && (Me(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0), l = new N.Buf8(r.w_size), N.arraySet(l, e, d - r.w_size, r.w_size, 0), e = l, d = r.w_size), s = t.avail_in, o = t.next_in, h = t.input, t.avail_in = d, t.next_in = 0, t.input = e, Pe(r); r.lookahead >= we;) { for (n = r.strstart, i = r.lookahead - (we - 1); r.ins_h = (r.ins_h << r.hash_shift ^ r.window[n + we - 1]) & r.hash_mask, r.prev[n & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = n, n++, --i;); r.strstart = n, r.lookahead = we - 1, Pe(r) } return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = we - 1, r.match_available = 0, t.next_in = o, t.input = h, t.avail_in = s, r.wrap = a, Jt } Kt = [new Je(0, 0, 0, 0, Xe), new Je(4, 4, 8, 4, We), new Je(4, 5, 16, 8, We), new Je(4, 6, 32, 32, We), new Je(4, 4, 16, 16, Ye), new Je(8, 16, 32, 32, Ye), new Je(8, 16, 128, 128, Ye), new Je(8, 32, 128, 256, Ye), new Je(32, 128, 258, 1024, Ye), new Je(32, 258, 258, 4096, Ye)]; var or = nr, hr = rr, lr = tr, dr = Ve, fr = er, cr = ir, ur = ar, _r = sr, pr = "pako deflate (from Nodeca project)", gr = { deflateInit: nr, deflateInit2: rr, deflateReset: tr, deflateResetKeep: Ve, deflateSetHeader: er, deflate: ir, deflateEnd: ar, deflateSetDictionary: sr, deflateInfo: pr }, vr = !0, mr = !0; try { String.fromCharCode.apply(null, [0]) } catch (t) { vr = !1 } try { String.fromCharCode.apply(null, new Uint8Array(1)) } catch (t) { mr = !1 } for (var wr = new N.Buf8(256), br = 0; br < 256; br++)wr[br] = 252 <= br ? 6 : 248 <= br ? 5 : 240 <= br ? 4 : 224 <= br ? 3 : 192 <= br ? 2 : 1; wr[254] = wr[254] = 1; var kr = function (t) { for (var e, r, n, i, a = t.length, s = 0, o = 0; o < a; o++)55296 == (64512 & (r = t.charCodeAt(o))) && o + 1 < a && 56320 == (64512 & (n = t.charCodeAt(o + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), o++), s += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4; for (e = new N.Buf8(s), o = i = 0; i < s; o++)55296 == (64512 & (r = t.charCodeAt(o))) && o + 1 < a && 56320 == (64512 & (n = t.charCodeAt(o + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), o++), r < 128 ? e[i++] = r : (r < 2048 ? e[i++] = 192 | r >>> 6 : (r < 65536 ? e[i++] = 224 | r >>> 12 : (e[i++] = 240 | r >>> 18, e[i++] = 128 | r >>> 12 & 63), e[i++] = 128 | r >>> 6 & 63), e[i++] = 128 | 63 & r); return e }; function yr (t, e) { if (e < 65534 && (t.subarray && mr || !t.subarray && vr)) return String.fromCharCode.apply(null, N.shrinkBuf(t, e)); for (var r = "", n = 0; n < e; n++)r += String.fromCharCode(t[n]); return r } var xr = function (t) { return yr(t, t.length) }, zr = function (t) { for (var e = new N.Buf8(t.length), r = 0, n = e.length; r < n; r++)e[r] = t.charCodeAt(r); return e }, Br = function (t, e) { for (var r, n, i = e || t.length, a = new Array(2 * i), s = 0, o = 0; o < i;)if ((r = t[o++]) < 128) a[s++] = r; else if (4 < (n = wr[r])) a[s++] = 65533, o += n - 1; else { for (r &= 2 === n ? 31 : 3 === n ? 15 : 7; 1 < n && o < i;)r = r << 6 | 63 & t[o++], n--; 1 < n ? a[s++] = 65533 : r < 65536 ? a[s++] = r : (r -= 65536, a[s++] = 55296 | r >> 10 & 1023, a[s++] = 56320 | 1023 & r) } return yr(a, s) }, Sr = function (t, e) { var r; for ((e = e || t.length) > t.length && (e = t.length), r = e - 1; 0 <= r && 128 == (192 & t[r]);)r--; return !(r < 0) && 0 !== r && r + wr[t[r]] > e ? r : e }, Ar = { string2buf: kr, buf2binstring: xr, binstring2buf: zr, buf2string: Br, utf8border: Sr }; function Cr () { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0 } var Er = Cr, Dr = Object.prototype.toString, Rr = 0, Or = 4, Zr = 0, Nr = 1, Hr = 2, Fr = -1, Mr = 0, Ir = 8; function Ur (t) { if (!(this instanceof Ur)) return new Ur(t); this.options = N.assign({ level: Fr, method: Ir, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: Mr, to: "" }, t || {}); var e = this.options; if (e.raw && 0 < e.windowBits ? e.windowBits = -e.windowBits : e.gzip && 0 < e.windowBits && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Er, this.strm.avail_out = 0, (r = gr.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy)) !== Zr) throw new Error(Pt[r]); if (e.header && gr.deflateSetHeader(this.strm, e.header), e.dictionary) { var r, n = "string" == typeof e.dictionary ? Ar.string2buf(e.dictionary) : "[object ArrayBuffer]" === Dr.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary; if ((r = gr.deflateSetDictionary(this.strm, n)) !== Zr) throw new Error(Pt[r]); this._dict_set = !0 } } function Tr (t, e) { var r = new Ur(e); if (r.push(t, !0), r.err) throw r.msg || Pt[r.err]; return r.result } function Lr (t, e) { return (e = e || {}).raw = !0, Tr(t, e) } function Kr (t, e) { return (e = e || {}).gzip = !0, Tr(t, e) } Ur.prototype.push = function (t, e) { var r, n, i = this.strm, a = this.options.chunkSize; if (this.ended) return !1; n = e === ~~e ? e : !0 === e ? Or : Rr, "string" == typeof t ? i.input = Ar.string2buf(t) : "[object ArrayBuffer]" === Dr.call(t) ? i.input = new Uint8Array(t) : i.input = t, i.next_in = 0, i.avail_in = i.input.length; do { if (0 === i.avail_out && (i.output = new N.Buf8(a), i.next_out = 0, i.avail_out = a), (r = gr.deflate(i, n)) !== Nr && r !== Zr) return this.onEnd(r), !(this.ended = !0); 0 !== i.avail_out && (0 !== i.avail_in || n !== Or && n !== Hr) || ("string" === this.options.to ? this.onData(Ar.buf2binstring(N.shrinkBuf(i.output, i.next_out))) : this.onData(N.shrinkBuf(i.output, i.next_out))) } while ((0 < i.avail_in || 0 === i.avail_out) && r !== Nr); return n === Or ? (r = gr.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === Zr) : n !== Hr || (this.onEnd(Zr), !(i.avail_out = 0)) }, Ur.prototype.onData = function (t) { this.chunks.push(t) }, Ur.prototype.onEnd = function (t) { t === Zr && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = N.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg }; var jr = Ur, Pr = Tr, Xr = Lr, Wr = Kr, Yr = { Deflate: Ur, deflate: Tr, deflateRaw: Lr, gzip: Kr }, Gr = 30, qr = 12, Jr = function (t, e) { var r, n, i, a, s, o, h = t.state, l = t.next_in, d = t.input, f = l + (t.avail_in - 5), c = t.next_out, u = t.output, _ = c - (e - t.avail_out), p = c + (t.avail_out - 257), g = h.dmax, v = h.wsize, m = h.whave, w = h.wnext, b = h.window, k = h.hold, y = h.bits, x = h.lencode, z = h.distcode, B = (1 << h.lenbits) - 1, S = (1 << h.distbits) - 1; t: do { y < 15 && (k += d[l++] << y, y += 8, k += d[l++] << y, y += 8), r = x[k & B]; e: for (; ;) { if (k >>>= n = r >>> 24, y -= n, 0 === (n = r >>> 16 & 255)) u[c++] = 65535 & r; else { if (!(16 & n)) { if (0 == (64 & n)) { r = x[(65535 & r) + (k & (1 << n) - 1)]; continue e } if (32 & n) { h.mode = qr; break t } t.msg = "invalid literal/length code", h.mode = Gr; break t } i = 65535 & r, (n &= 15) && (y < n && (k += d[l++] << y, y += 8), i += k & (1 << n) - 1, k >>>= n, y -= n), y < 15 && (k += d[l++] << y, y += 8, k += d[l++] << y, y += 8), r = z[k & S]; r: for (; ;) { if (k >>>= n = r >>> 24, y -= n, !(16 & (n = r >>> 16 & 255))) { if (0 == (64 & n)) { r = z[(65535 & r) + (k & (1 << n) - 1)]; continue r } t.msg = "invalid distance code", h.mode = Gr; break t } if (a = 65535 & r, y < (n &= 15) && (k += d[l++] << y, (y += 8) < n && (k += d[l++] << y, y += 8)), g < (a += k & (1 << n) - 1)) { t.msg = "invalid distance too far back", h.mode = Gr; break t } if (k >>>= n, y -= n, (n = c - _) < a) { if (m < (n = a - n) && h.sane) { t.msg = "invalid distance too far back", h.mode = Gr; break t } if (o = b, (s = 0) === w) { if (s += v - n, n < i) { for (i -= n; u[c++] = b[s++], --n;); s = c - a, o = u } } else if (w < n) { if (s += v + w - n, (n -= w) < i) { for (i -= n; u[c++] = b[s++], --n;); if (s = 0, w < i) { for (i -= n = w; u[c++] = b[s++], --n;); s = c - a, o = u } } } else if (s += w - n, n < i) { for (i -= n; u[c++] = b[s++], --n;); s = c - a, o = u } for (; 2 < i;)u[c++] = o[s++], u[c++] = o[s++], u[c++] = o[s++], i -= 3; i && (u[c++] = o[s++], 1 < i && (u[c++] = o[s++])) } else { for (s = c - a; u[c++] = u[s++], u[c++] = u[s++], u[c++] = u[s++], 2 < (i -= 3);); i && (u[c++] = u[s++], 1 < i && (u[c++] = u[s++])) } break } } break } } while (l < f && c < p); l -= i = y >> 3, k &= (1 << (y -= i << 3)) - 1, t.next_in = l, t.next_out = c, t.avail_in = l < f ? f - l + 5 : 5 - (l - f), t.avail_out = c < p ? p - c + 257 : 257 - (c - p), h.hold = k, h.bits = y }, $r = 15, Qr = 852, Vr = 592, tn = 0, en = 1, rn = 2, nn = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], an = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], sn = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], on = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64], hn = function (t, e, r, n, i, a, s, o) { for (var h, l, d, f, c, u, _, p, g, v = o.bits, m = 0, w = 0, b = 0, k = 0, y = 0, x = 0, z = 0, B = 0, S = 0, A = 0, C = null, E = 0, D = new N.Buf16($r + 1), R = new N.Buf16($r + 1), O = null, Z = 0, m = 0; m <= $r; m++)D[m] = 0; for (w = 0; w < n; w++)D[e[r + w]]++; for (y = v, k = $r; 1 <= k && 0 === D[k]; k--); if (k < y && (y = k), 0 === k) return i[a++] = 20971520, i[a++] = 20971520, o.bits = 1, 0; for (b = 1; b < k && 0 === D[b]; b++); for (y < b && (y = b), m = B = 1; m <= $r; m++)if (B <<= 1, (B -= D[m]) < 0) return -1; if (0 < B && (t === tn || 1 !== k)) return -1; for (R[1] = 0, m = 1; m < $r; m++)R[m + 1] = R[m] + D[m]; for (w = 0; w < n; w++)0 !== e[r + w] && (s[R[e[r + w]]++] = w); if (u = t === tn ? (C = O = s, 19) : t === en ? (C = nn, E -= 257, O = an, Z -= 257, 256) : (C = sn, O = on, -1), m = b, c = a, z = w = A = 0, d = -1, f = (S = 1 << (x = y)) - 1, t === en && Qr < S || t === rn && Vr < S) return 1; for (; ;) { for (_ = m - z, g = s[w] < u ? (p = 0, s[w]) : s[w] > u ? (p = O[Z + s[w]], C[E + s[w]]) : (p = 96, 0), h = 1 << m - z, b = l = 1 << x; i[c + (A >> z) + (l -= h)] = _ << 24 | p << 16 | g | 0, 0 !== l;); for (h = 1 << m - 1; A & h;)h >>= 1; if (0 !== h ? (A &= h - 1, A += h) : A = 0, w++, 0 == --D[m]) { if (m === k) break; m = e[r + s[w]] } if (y < m && (A & f) !== d) { for (0 === z && (z = y), c += b, B = 1 << (x = m - z); x + z < k && !((B -= D[x + z]) <= 0);)x++, B <<= 1; if (S += 1 << x, t === en && Qr < S || t === rn && Vr < S) return 1; i[d = A & f] = y << 24 | x << 16 | c - a | 0 } } return 0 !== A && (i[c + A] = m - z << 24 | 64 << 16 | 0), o.bits = y, 0 }, ln = 0, dn = 1, fn = 2, cn = 4, un = 5, _n = 6, pn = 0, gn = 1, vn = 2, mn = -2, wn = -3, bn = -4, kn = -5, yn = 8, xn = 1, zn = 2, Bn = 3, Sn = 4, An = 5, Cn = 6, En = 7, Dn = 8, Rn = 9, On = 10, Zn = 11, Nn = 12, Hn = 13, Fn = 14, Mn = 15, In = 16, Un = 17, Tn = 18, Ln = 19, Kn = 20, jn = 21, Pn = 22, Xn = 23, Wn = 24, Yn = 25, Gn = 26, qn = 27, Jn = 28, $n = 29, Qn = 30, Vn = 31, ti = 32, ei = 852, ri = 592, ni = 15, ii = ni; function ai (t) { return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24) } function si () { this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new N.Buf16(320), this.work = new N.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0 } function oi (t) { var e; return t && t.state ? (e = t.state, t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = xn, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new N.Buf32(ei), e.distcode = e.distdyn = new N.Buf32(ri), e.sane = 1, e.back = -1, pn) : mn } function hi (t) { var e; return t && t.state ? ((e = t.state).wsize = 0, e.whave = 0, e.wnext = 0, oi(t)) : mn } function li (t, e) { var r, n; return t && t.state ? (n = t.state, e < 0 ? (r = 0, e = -e) : (r = 1 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || 15 < e) ? mn : (null !== n.window && n.wbits !== e && (n.window = null), n.wrap = r, n.wbits = e, hi(t))) : mn } function di (t, e) { var r, n; return t ? (n = new si, (t.state = n).window = null, (r = li(t, e)) !== pn && (t.state = null), r) : mn } function fi (t) { return di(t, ii) } var ci, ui, _i = !0; function pi (t) { if (_i) { var e; for (ci = new N.Buf32(512), ui = new N.Buf32(32), e = 0; e < 144;)t.lens[e++] = 8; for (; e < 256;)t.lens[e++] = 9; for (; e < 280;)t.lens[e++] = 7; for (; e < 288;)t.lens[e++] = 8; for (hn(dn, t.lens, 0, 288, ci, 0, t.work, { bits: 9 }), e = 0; e < 32;)t.lens[e++] = 5; hn(fn, t.lens, 0, 32, ui, 0, t.work, { bits: 5 }), _i = !1 } t.lencode = ci, t.lenbits = 9, t.distcode = ui, t.distbits = 5 } function gi (t, e, r, n) { var i, a = t.state; return null === a.window && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new N.Buf8(a.wsize)), n >= a.wsize ? (N.arraySet(a.window, e, r - a.wsize, a.wsize, 0), a.wnext = 0, a.whave = a.wsize) : (n < (i = a.wsize - a.wnext) && (i = n), N.arraySet(a.window, e, r - n, i, a.wnext), (n -= i) ? (N.arraySet(a.window, e, r - n, n, 0), a.wnext = n, a.whave = a.wsize) : (a.wnext += i, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += i))), 0 } function vi (t, e) { var r, n, i, a, s, o, h, l, d, f, c, u, _, p, g, v, m, w, b, k, y, x, z, B, S = 0, A = new N.Buf8(4), C = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; if (!t || !t.state || !t.output || !t.input && 0 !== t.avail_in) return mn; (r = t.state).mode === Nn && (r.mode = Hn), s = t.next_out, i = t.output, h = t.avail_out, a = t.next_in, n = t.input, o = t.avail_in, l = r.hold, d = r.bits, f = o, c = h, x = pn; t: for (; ;)switch (r.mode) { case xn: if (0 === r.wrap) { r.mode = Hn; break } for (; d < 16;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } if (2 & r.wrap && 35615 === l) { A[r.check = 0] = 255 & l, A[1] = l >>> 8 & 255, r.check = jt(r.check, A, 2, 0), d = l = 0, r.mode = zn; break } if (r.flags = 0, r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & l) << 8) + (l >> 8)) % 31) { t.msg = "incorrect header check", r.mode = Qn; break } if ((15 & l) !== yn) { t.msg = "unknown compression method", r.mode = Qn; break } if (d -= 4, y = 8 + (15 & (l >>>= 4)), 0 === r.wbits) r.wbits = y; else if (y > r.wbits) { t.msg = "invalid window size", r.mode = Qn; break } r.dmax = 1 << y, t.adler = r.check = 1, r.mode = 512 & l ? On : Nn, d = l = 0; break; case zn: for (; d < 16;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } if (r.flags = l, (255 & r.flags) !== yn) { t.msg = "unknown compression method", r.mode = Qn; break } if (57344 & r.flags) { t.msg = "unknown header flags set", r.mode = Qn; break } r.head && (r.head.text = l >> 8 & 1), 512 & r.flags && (A[0] = 255 & l, A[1] = l >>> 8 & 255, r.check = jt(r.check, A, 2, 0)), d = l = 0, r.mode = Bn; case Bn: for (; d < 32;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } r.head && (r.head.time = l), 512 & r.flags && (A[0] = 255 & l, A[1] = l >>> 8 & 255, A[2] = l >>> 16 & 255, A[3] = l >>> 24 & 255, r.check = jt(r.check, A, 4, 0)), d = l = 0, r.mode = Sn; case Sn: for (; d < 16;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } r.head && (r.head.xflags = 255 & l, r.head.os = l >> 8), 512 & r.flags && (A[0] = 255 & l, A[1] = l >>> 8 & 255, r.check = jt(r.check, A, 2, 0)), d = l = 0, r.mode = An; case An: if (1024 & r.flags) { for (; d < 16;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } r.length = l, r.head && (r.head.extra_len = l), 512 & r.flags && (A[0] = 255 & l, A[1] = l >>> 8 & 255, r.check = jt(r.check, A, 2, 0)), d = l = 0 } else r.head && (r.head.extra = null); r.mode = Cn; case Cn: if (1024 & r.flags && (o < (u = r.length) && (u = o), u && (r.head && (y = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Array(r.head.extra_len)), N.arraySet(r.head.extra, n, a, u, y)), 512 & r.flags && (r.check = jt(r.check, n, u, a)), o -= u, a += u, r.length -= u), r.length)) break t; r.length = 0, r.mode = En; case En: if (2048 & r.flags) { if (0 === o) break t; for (u = 0; y = n[a + u++], r.head && y && r.length < 65536 && (r.head.name += String.fromCharCode(y)), y && u < o;); if (512 & r.flags && (r.check = jt(r.check, n, u, a)), o -= u, a += u, y) break t } else r.head && (r.head.name = null); r.length = 0, r.mode = Dn; case Dn: if (4096 & r.flags) { if (0 === o) break t; for (u = 0; y = n[a + u++], r.head && y && r.length < 65536 && (r.head.comment += String.fromCharCode(y)), y && u < o;); if (512 & r.flags && (r.check = jt(r.check, n, u, a)), o -= u, a += u, y) break t } else r.head && (r.head.comment = null); r.mode = Rn; case Rn: if (512 & r.flags) { for (; d < 16;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } if (l !== (65535 & r.check)) { t.msg = "header crc mismatch", r.mode = Qn; break } d = l = 0 } r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), t.adler = r.check = 0, r.mode = Nn; break; case On: for (; d < 32;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } t.adler = r.check = ai(l), d = l = 0, r.mode = Zn; case Zn: if (0 === r.havedict) return t.next_out = s, t.avail_out = h, t.next_in = a, t.avail_in = o, r.hold = l, r.bits = d, vn; t.adler = r.check = 1, r.mode = Nn; case Nn: if (e === un || e === _n) break t; case Hn: if (r.last) { l >>>= 7 & d, d -= 7 & d, r.mode = qn; break } for (; d < 3;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } switch (r.last = 1 & l, --d, 3 & (l >>>= 1)) { case 0: r.mode = Fn; break; case 1: if (pi(r), r.mode = Kn, e !== _n) break; l >>>= 2, d -= 2; break t; case 2: r.mode = Un; break; case 3: t.msg = "invalid block type", r.mode = Qn }l >>>= 2, d -= 2; break; case Fn: for (l >>>= 7 & d, d -= 7 & d; d < 32;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } if ((65535 & l) != (l >>> 16 ^ 65535)) { t.msg = "invalid stored block lengths", r.mode = Qn; break } if (r.length = 65535 & l, d = l = 0, r.mode = Mn, e === _n) break t; case Mn: r.mode = In; case In: if (u = r.length) { if (o < u && (u = o), h < u && (u = h), 0 === u) break t; N.arraySet(i, n, a, u, s), o -= u, a += u, h -= u, s += u, r.length -= u; break } r.mode = Nn; break; case Un: for (; d < 14;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } if (r.nlen = 257 + (31 & l), l >>>= 5, d -= 5, r.ndist = 1 + (31 & l), l >>>= 5, d -= 5, r.ncode = 4 + (15 & l), l >>>= 4, d -= 4, 286 < r.nlen || 30 < r.ndist) { t.msg = "too many length or distance symbols", r.mode = Qn; break } r.have = 0, r.mode = Tn; case Tn: for (; r.have < r.ncode;) { for (; d < 3;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } r.lens[C[r.have++]] = 7 & l, l >>>= 3, d -= 3 } for (; r.have < 19;)r.lens[C[r.have++]] = 0; if (r.lencode = r.lendyn, r.lenbits = 7, z = { bits: r.lenbits }, x = hn(ln, r.lens, 0, 19, r.lencode, 0, r.work, z), r.lenbits = z.bits, x) { t.msg = "invalid code lengths set", r.mode = Qn; break } r.have = 0, r.mode = Ln; case Ln: for (; r.have < r.nlen + r.ndist;) { for (; v = (S = r.lencode[l & (1 << r.lenbits) - 1]) >>> 16 & 255, m = 65535 & S, !((g = S >>> 24) <= d);) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } if (m < 16) l >>>= g, d -= g, r.lens[r.have++] = m; else { if (16 === m) { for (B = g + 2; d < B;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } if (l >>>= g, d -= g, 0 === r.have) { t.msg = "invalid bit length repeat", r.mode = Qn; break } y = r.lens[r.have - 1], u = 3 + (3 & l), l >>>= 2, d -= 2 } else if (17 === m) { for (B = g + 3; d < B;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } d -= g, y = 0, u = 3 + (7 & (l >>>= g)), l >>>= 3, d -= 3 } else { for (B = g + 7; d < B;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } d -= g, y = 0, u = 11 + (127 & (l >>>= g)), l >>>= 7, d -= 7 } if (r.have + u > r.nlen + r.ndist) { t.msg = "invalid bit length repeat", r.mode = Qn; break } for (; u--;)r.lens[r.have++] = y } } if (r.mode === Qn) break; if (0 === r.lens[256]) { t.msg = "invalid code -- missing end-of-block", r.mode = Qn; break } if (r.lenbits = 9, z = { bits: r.lenbits }, x = hn(dn, r.lens, 0, r.nlen, r.lencode, 0, r.work, z), r.lenbits = z.bits, x) { t.msg = "invalid literal/lengths set", r.mode = Qn; break } if (r.distbits = 6, r.distcode = r.distdyn, z = { bits: r.distbits }, x = hn(fn, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, z), r.distbits = z.bits, x) { t.msg = "invalid distances set", r.mode = Qn; break } if (r.mode = Kn, e === _n) break t; case Kn: r.mode = jn; case jn: if (6 <= o && 258 <= h) { t.next_out = s, t.avail_out = h, t.next_in = a, t.avail_in = o, r.hold = l, r.bits = d, Jr(t, c), s = t.next_out, i = t.output, h = t.avail_out, a = t.next_in, n = t.input, o = t.avail_in, l = r.hold, d = r.bits, r.mode === Nn && (r.back = -1); break } for (r.back = 0; v = (S = r.lencode[l & (1 << r.lenbits) - 1]) >>> 16 & 255, m = 65535 & S, !((g = S >>> 24) <= d);) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } if (v && 0 == (240 & v)) { for (w = g, b = v, k = m; v = (S = r.lencode[k + ((l & (1 << w + b) - 1) >> w)]) >>> 16 & 255, m = 65535 & S, !(w + (g = S >>> 24) <= d);) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } l >>>= w, d -= w, r.back += w } if (l >>>= g, d -= g, r.back += g, r.length = m, 0 === v) { r.mode = Gn; break } if (32 & v) { r.back = -1, r.mode = Nn; break } if (64 & v) { t.msg = "invalid literal/length code", r.mode = Qn; break } r.extra = 15 & v, r.mode = Pn; case Pn: if (r.extra) { for (B = r.extra; d < B;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } r.length += l & (1 << r.extra) - 1, l >>>= r.extra, d -= r.extra, r.back += r.extra } r.was = r.length, r.mode = Xn; case Xn: for (; v = (S = r.distcode[l & (1 << r.distbits) - 1]) >>> 16 & 255, m = 65535 & S, !((g = S >>> 24) <= d);) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } if (0 == (240 & v)) { for (w = g, b = v, k = m; v = (S = r.distcode[k + ((l & (1 << w + b) - 1) >> w)]) >>> 16 & 255, m = 65535 & S, !(w + (g = S >>> 24) <= d);) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } l >>>= w, d -= w, r.back += w } if (l >>>= g, d -= g, r.back += g, 64 & v) { t.msg = "invalid distance code", r.mode = Qn; break } r.offset = m, r.extra = 15 & v, r.mode = Wn; case Wn: if (r.extra) { for (B = r.extra; d < B;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } r.offset += l & (1 << r.extra) - 1, l >>>= r.extra, d -= r.extra, r.back += r.extra } if (r.offset > r.dmax) { t.msg = "invalid distance too far back", r.mode = Qn; break } r.mode = Yn; case Yn: if (0 === h) break t; if (u = c - h, r.offset > u) { if ((u = r.offset - u) > r.whave && r.sane) { t.msg = "invalid distance too far back", r.mode = Qn; break } _ = u > r.wnext ? (u -= r.wnext, r.wsize - u) : r.wnext - u, u > r.length && (u = r.length), p = r.window } else p = i, _ = s - r.offset, u = r.length; for (h < u && (u = h), h -= u, r.length -= u; i[s++] = p[_++], --u;); 0 === r.length && (r.mode = jn); break; case Gn: if (0 === h) break t; i[s++] = r.length, h--, r.mode = jn; break; case qn: if (r.wrap) { for (; d < 32;) { if (0 === o) break t; o--, l |= n[a++] << d, d += 8 } if (c -= h, t.total_out += c, r.total += c, c && (t.adler = r.check = (r.flags ? jt : It)(r.check, i, c, s - c)), c = h, (r.flags ? l : ai(l)) !== r.check) { t.msg = "incorrect data check", r.mode = Qn; break } d = l = 0 } r.mode = Jn; case Jn: if (r.wrap && r.flags) { for (; d < 32;) { if (0 === o) break t; o--, l += n[a++] << d, d += 8 } if (l !== (4294967295 & r.total)) { t.msg = "incorrect length check", r.mode = Qn; break } d = l = 0 } r.mode = $n; case $n: x = gn; break t; case Qn: x = wn; break t; case Vn: return bn; case ti: default: return mn }return t.next_out = s, t.avail_out = h, t.next_in = a, t.avail_in = o, r.hold = l, r.bits = d, (r.wsize || c !== t.avail_out && r.mode < Qn && (r.mode < qn || e !== cn)) && gi(t, t.output, t.next_out, c - t.avail_out), f -= t.avail_in, c -= t.avail_out, t.total_in += f, t.total_out += c, r.total += c, r.wrap && c && (t.adler = r.check = (r.flags ? jt : It)(r.check, i, c, t.next_out - c)), t.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === Nn ? 128 : 0) + (r.mode === Kn || r.mode === Mn ? 256 : 0), (0 == f && 0 === c || e === cn) && x === pn && (x = kn), x } function mi (t) { if (!t || !t.state) return mn; var e = t.state; return e.window && (e.window = null), t.state = null, pn } function wi (t, e) { var r; return !t || !t.state || 0 == (2 & (r = t.state).wrap) ? mn : ((r.head = e).done = !1, pn) } function bi (t, e) { var r, n = e.length; return !t || !t.state || 0 !== (r = t.state).wrap && r.mode !== Zn ? mn : r.mode === Zn && It(1, e, n, 0) !== r.check ? wn : gi(t, e, n, n) ? (r.mode = Vn, bn) : (r.havedict = 1, pn) } var ki = hi, yi = li, xi = oi, zi = fi, Bi = di, Si = vi, Ai = mi, Ci = wi, Ei = bi, Di = "pako inflate (from Nodeca project)", Ri = { inflateReset: hi, inflateReset2: li, inflateResetKeep: oi, inflateInit: fi, inflateInit2: di, inflate: vi, inflateEnd: mi, inflateGetHeader: wi, inflateSetDictionary: bi, inflateInfo: Di }, Oi = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 }; function Zi () { this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1 } var Ni = Zi, Hi = Object.prototype.toString; function Fi (t) { if (!(this instanceof Fi)) return new Fi(t); this.options = N.assign({ chunkSize: 16384, windowBits: 0, to: "" }, t || {}); var e = this.options; e.raw && 0 <= e.windowBits && e.windowBits < 16 && (e.windowBits = -e.windowBits, 0 === e.windowBits && (e.windowBits = -15)), !(0 <= e.windowBits && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32), 15 < e.windowBits && e.windowBits < 48 && 0 == (15 & e.windowBits) && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Er, this.strm.avail_out = 0; var r = Ri.inflateInit2(this.strm, e.windowBits); if (r !== Oi.Z_OK) throw new Error(Pt[r]); if (this.header = new Ni, Ri.inflateGetHeader(this.strm, this.header), e.dictionary && ("string" == typeof e.dictionary ? e.dictionary = Ar.string2buf(e.dictionary) : "[object ArrayBuffer]" === Hi.call(e.dictionary) && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (r = Ri.inflateSetDictionary(this.strm, e.dictionary)) !== Oi.Z_OK)) throw new Error(Pt[r]) } function Mi (t, e) { var r = new Fi(e); if (r.push(t, !0), r.err) throw r.msg || Pt[r.err]; return r.result } function Ii (t, e) { return (e = e || {}).raw = !0, Mi(t, e) } Fi.prototype.push = function (t, e) { var r, n, i, a, s, o = this.strm, h = this.options.chunkSize, l = this.options.dictionary, d = !1; if (this.ended) return !1; n = e === ~~e ? e : !0 === e ? Oi.Z_FINISH : Oi.Z_NO_FLUSH, "string" == typeof t ? o.input = Ar.binstring2buf(t) : "[object ArrayBuffer]" === Hi.call(t) ? o.input = new Uint8Array(t) : o.input = t, o.next_in = 0, o.avail_in = o.input.length; do { if (0 === o.avail_out && (o.output = new N.Buf8(h), o.next_out = 0, o.avail_out = h), (r = Ri.inflate(o, Oi.Z_NO_FLUSH)) === Oi.Z_NEED_DICT && l && (r = Ri.inflateSetDictionary(this.strm, l)), r === Oi.Z_BUF_ERROR && !0 === d && (r = Oi.Z_OK, d = !1), r !== Oi.Z_STREAM_END && r !== Oi.Z_OK) return this.onEnd(r), !(this.ended = !0); o.next_out && (0 !== o.avail_out && r !== Oi.Z_STREAM_END && (0 !== o.avail_in || n !== Oi.Z_FINISH && n !== Oi.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i = Ar.utf8border(o.output, o.next_out), a = o.next_out - i, s = Ar.buf2string(o.output, i), o.next_out = a, o.avail_out = h - a, a && N.arraySet(o.output, o.output, i, a, 0), this.onData(s)) : this.onData(N.shrinkBuf(o.output, o.next_out)))), 0 === o.avail_in && 0 === o.avail_out && (d = !0) } while ((0 < o.avail_in || 0 === o.avail_out) && r !== Oi.Z_STREAM_END); return r === Oi.Z_STREAM_END && (n = Oi.Z_FINISH), n === Oi.Z_FINISH ? (r = Ri.inflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === Oi.Z_OK) : n !== Oi.Z_SYNC_FLUSH || (this.onEnd(Oi.Z_OK), !(o.avail_out = 0)) }, Fi.prototype.onData = function (t) { this.chunks.push(t) }, Fi.prototype.onEnd = function (t) { t === Oi.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = N.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg }; var Ui = Fi, Ti = Mi, Li = Ii, Ki = Mi, ji = { Inflate: Fi, inflate: Mi, inflateRaw: Ii, ungzip: Mi }, Pi = N.assign, Xi = {}; Pi(Xi, Yr, ji, Oi); for (var Wi = Xi, Yi = na, Gi = aa, qi = ha, Ji = [], $i = [], Qi = "undefined" != typeof Uint8Array ? Uint8Array : Array, Vi = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ta = 0, ea = Vi.length; ta < ea; ++ta)Ji[ta] = Vi[ta], $i[Vi.charCodeAt(ta)] = ta; function ra (t) { var e = t.length; if (0 < e % 4) throw new Error("Invalid string. Length must be a multiple of 4"); var r = t.indexOf("="); return -1 === r && (r = e), [r, r === e ? 0 : 4 - r % 4] } function na (t) { var e = ra(t), r = e[0], n = e[1]; return 3 * (r + n) / 4 - n } function ia (t, e, r) { return 3 * (e + r) / 4 - r } function aa (t) { for (var e, r = ra(t), n = r[0], i = r[1], a = new Qi(ia(t, n, i)), s = 0, o = 0 < i ? n - 4 : n, h = 0; h < o; h += 4)e = $i[t.charCodeAt(h)] << 18 | $i[t.charCodeAt(h + 1)] << 12 | $i[t.charCodeAt(h + 2)] << 6 | $i[t.charCodeAt(h + 3)], a[s++] = e >> 16 & 255, a[s++] = e >> 8 & 255, a[s++] = 255 & e; return 2 === i && (e = $i[t.charCodeAt(h)] << 2 | $i[t.charCodeAt(h + 1)] >> 4, a[s++] = 255 & e), 1 === i && (e = $i[t.charCodeAt(h)] << 10 | $i[t.charCodeAt(h + 1)] << 4 | $i[t.charCodeAt(h + 2)] >> 2, a[s++] = e >> 8 & 255, a[s++] = 255 & e), a } function sa (t) { return Ji[t >> 18 & 63] + Ji[t >> 12 & 63] + Ji[t >> 6 & 63] + Ji[63 & t] } function oa (t, e, r) { for (var n, i = [], a = e; a < r; a += 3)n = (t[a] << 16 & 16711680) + (t[a + 1] << 8 & 65280) + (255 & t[a + 2]), i.push(sa(n)); return i.join("") } function ha (t) { for (var e, r = t.length, n = r % 3, i = [], a = 0, s = r - n; a < s; a += 16383)i.push(oa(t, a, s < a + 16383 ? s : a + 16383)); return 1 == n ? (e = t[r - 1], i.push(Ji[e >> 2] + Ji[e << 4 & 63] + "==")) : 2 == n && (e = (t[r - 2] << 8) + t[r - 1], i.push(Ji[e >> 10] + Ji[e >> 4 & 63] + Ji[e << 2 & 63] + "=")), i.join("") } $i["-".charCodeAt(0)] = 62, $i["_".charCodeAt(0)] = 63; var la = { byteLength: Yi, toByteArray: Gi, fromByteArray: qi }; function da (t, e) { var r = t; function h (t, e) { return t << e | t >>> 32 - e } function l (t, e) { var r, n, i = 2147483648 & t, a = 2147483648 & e, s = (1073741823 & t) + (1073741823 & e); return (r = 1073741824 & t) & (n = 1073741824 & e) ? 2147483648 ^ s ^ i ^ a : r | n ? 1073741824 & s ? 3221225472 ^ s ^ i ^ a : 1073741824 ^ s ^ i ^ a : s ^ i ^ a } function n (t, e, r, n, i, a, s) { var o; return t = l(t, l(l((o = e) & r | ~o & n, i), s)), l(h(t, a), e) } function i (t, e, r, n, i, a, s) { var o; return t = l(t, l(l(e & (o = n) | r & ~o, i), s)), l(h(t, a), e) } function a (t, e, r, n, i, a, s) { return t = l(t, l(l(e ^ r ^ n, i), s)), l(h(t, a), e) } function s (t, e, r, n, i, a, s) { return t = l(t, l(l(r ^ (e | ~n), i), s)), l(h(t, a), e) } function o (t) { for (var e = "", r = "", n = void 0, n = 0; n <= 3; n++)e += (r = "0" + (t >>> 8 * n & 255).toString(16)).substr(r.length - 2, 2); return e } for (var d = Array(), f = void 0, c = void 0, u = void 0, _ = void 0, p = void 0, g = void 0, v = void 0, m = void 0, w = void 0, d = function (t) { for (var e = void 0, r = t.length, n = r + 8, i = 16 * (1 + (n - n % 64) / 64), a = Array(i - 1), s = 0, o = 0; o < r;)s = o % 4 * 8, a[e = (o - o % 4) / 4] = a[e] | t.charCodeAt(o) << s, o++; return s = o % 4 * 8, a[e = (o - o % 4) / 4] = a[e] | 128 << s, a[i - 2] = r << 3, a[i - 1] = r >>> 29, a }(r), g = 1732584193, v = 4023233417, m = 2562383102, w = 271733878, f = 0; f < d.length; f += 16)g = n(c = g, u = v, _ = m, p = w, d[f + 0], 7, 3614090360), w = n(w, g, v, m, d[f + 1], 12, 3905402710), m = n(m, w, g, v, d[f + 2], 17, 606105819), v = n(v, m, w, g, d[f + 3], 22, 3250441966), g = n(g, v, m, w, d[f + 4], 7, 4118548399), w = n(w, g, v, m, d[f + 5], 12, 1200080426), m = n(m, w, g, v, d[f + 6], 17, 2821735955), v = n(v, m, w, g, d[f + 7], 22, 4249261313), g = n(g, v, m, w, d[f + 8], 7, 1770035416), w = n(w, g, v, m, d[f + 9], 12, 2336552879), m = n(m, w, g, v, d[f + 10], 17, 4294925233), v = n(v, m, w, g, d[f + 11], 22, 2304563134), g = n(g, v, m, w, d[f + 12], 7, 1804603682), w = n(w, g, v, m, d[f + 13], 12, 4254626195), m = n(m, w, g, v, d[f + 14], 17, 2792965006), g = i(g, v = n(v, m, w, g, d[f + 15], 22, 1236535329), m, w, d[f + 1], 5, 4129170786), w = i(w, g, v, m, d[f + 6], 9, 3225465664), m = i(m, w, g, v, d[f + 11], 14, 643717713), v = i(v, m, w, g, d[f + 0], 20, 3921069994), g = i(g, v, m, w, d[f + 5], 5, 3593408605), w = i(w, g, v, m, d[f + 10], 9, 38016083), m = i(m, w, g, v, d[f + 15], 14, 3634488961), v = i(v, m, w, g, d[f + 4], 20, 3889429448), g = i(g, v, m, w, d[f + 9], 5, 568446438), w = i(w, g, v, m, d[f + 14], 9, 3275163606), m = i(m, w, g, v, d[f + 3], 14, 4107603335), v = i(v, m, w, g, d[f + 8], 20, 1163531501), g = i(g, v, m, w, d[f + 13], 5, 2850285829), w = i(w, g, v, m, d[f + 2], 9, 4243563512), m = i(m, w, g, v, d[f + 7], 14, 1735328473), g = a(g, v = i(v, m, w, g, d[f + 12], 20, 2368359562), m, w, d[f + 5], 4, 4294588738), w = a(w, g, v, m, d[f + 8], 11, 2272392833), m = a(m, w, g, v, d[f + 11], 16, 1839030562), v = a(v, m, w, g, d[f + 14], 23, 4259657740), g = a(g, v, m, w, d[f + 1], 4, 2763975236), w = a(w, g, v, m, d[f + 4], 11, 1272893353), m = a(m, w, g, v, d[f + 7], 16, 4139469664), v = a(v, m, w, g, d[f + 10], 23, 3200236656), g = a(g, v, m, w, d[f + 13], 4, 681279174), w = a(w, g, v, m, d[f + 0], 11, 3936430074), m = a(m, w, g, v, d[f + 3], 16, 3572445317), v = a(v, m, w, g, d[f + 6], 23, 76029189), g = a(g, v, m, w, d[f + 9], 4, 3654602809), w = a(w, g, v, m, d[f + 12], 11, 3873151461), m = a(m, w, g, v, d[f + 15], 16, 530742520), g = s(g, v = a(v, m, w, g, d[f + 2], 23, 3299628645), m, w, d[f + 0], 6, 4096336452), w = s(w, g, v, m, d[f + 7], 10, 1126891415), m = s(m, w, g, v, d[f + 14], 15, 2878612391), v = s(v, m, w, g, d[f + 5], 21, 4237533241), g = s(g, v, m, w, d[f + 12], 6, 1700485571), w = s(w, g, v, m, d[f + 3], 10, 2399980690), m = s(m, w, g, v, d[f + 10], 15, 4293915773), v = s(v, m, w, g, d[f + 1], 21, 2240044497), g = s(g, v, m, w, d[f + 8], 6, 1873313359), w = s(w, g, v, m, d[f + 15], 10, 4264355552), m = s(m, w, g, v, d[f + 6], 15, 2734768916), v = s(v, m, w, g, d[f + 13], 21, 1309151649), g = s(g, v, m, w, d[f + 4], 6, 4149444226), w = s(w, g, v, m, d[f + 11], 10, 3174756917), m = s(m, w, g, v, d[f + 2], 15, 718787259), v = s(v, m, w, g, d[f + 9], 21, 3951481745), g = l(g, c), v = l(v, u), m = l(m, _), w = l(w, p); return 32 == e ? o(g) + o(v) + o(m) + o(w) : o(v) + o(m) } var fa = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", ca = function (t) { var e = "", r = void 0, n = void 0, i = void 0, a = void 0, s = void 0, o = void 0, h = void 0, l = 0; for (t = ua(t); l < t.length;)a = (r = t.charCodeAt(l++)) >> 2, s = (3 & r) << 4 | (n = t.charCodeAt(l++)) >> 4, o = (15 & n) << 2 | (i = t.charCodeAt(l++)) >> 6, h = 63 & i, isNaN(n) ? o = h = 64 : isNaN(i) && (h = 64), e = e + fa.charAt(a) + fa.charAt(s) + fa.charAt(o) + fa.charAt(h); return e }, ua = function (t) { t = t.replace(/\r\n/g, "\n"); for (var e = "", r = 0; r < t.length; r++) { var n = t.charCodeAt(r); n < 128 ? e += String.fromCharCode(n) : (127 < n && n < 2048 ? e += String.fromCharCode(n >> 6 | 192) : (e += String.fromCharCode(n >> 12 | 224), e += String.fromCharCode(n >> 6 & 63 | 128)), e += String.fromCharCode(63 & n | 128)) } return e }, _a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; function pa (t) { t = t.replace(/\s|=/g, ""); for (var e, r, n = 0, i = []; n < t.length;) { switch (e = _a.indexOf(t.charAt(n)), n % 4) { case 0: break; case 1: i.push(String.fromCharCode(r << 2 | e >> 4)); break; case 2: i.push(String.fromCharCode((15 & r) << 4 | e >> 2)); break; case 3: i.push(String.fromCharCode((3 & r) << 6 | e)) }r = e, n++ } return i.join("") } function ga (t) { var e = pa(t).split("").map(function (t) { return t.charCodeAt(0) }), r = new Uint8Array(e), n = Wi.inflate(r); return String.fromCharCode.apply(null, new Uint16Array(n)) } var va = ""; function ma (t, e, r) { return encodeURIComponent(ca(t + "|" + e + "|" + r + "||")) } function wa (t, e, r) { va = +new Date; for (var n = ca(da(new String(t + e + r + va), 32).toUpperCase()).split(""), i = r.split("."), a = i[i.length - 1], s = i[i.length - 2], n = 0 == !(Number(s) % 2) ? n.reverse() : n, o = "", h = 0; h < n.length; h++)(h % 2 == 0 && Number(a) % 2 != 0 || h % 2 != 0 && Number(a) % 2 == 0) && (o += n[h]); return o.length < 16 && (o += o.split("").reverse().join("")), o.slice(0, 16) } function ba (t, e, r, n, i) { var a, s = wa(e, r, n), s = l.parse(s), o = ""; 1 === i && (o = d.encrypt(t, s, { mode: f })), 2 === i && (a = l.parse("Analysys_315$CBC"), o = d.encrypt(t, s, { iv: a })), o = o.ciphertext.toString().toUpperCase(); var h = Wi.gzip(o); return la.fromByteArray(h) } function ka (t) { if (1 != t.encryptType && 2 != t.encryptType) return t; var e = t.data, r = e[0].xcontext.$lib, n = e[0].appid, i = e[0].xcontext.$lib_version, a = t.encryptType; return t.data = ba(JSON.stringify(e), r, n, i, a), t.url += "&spv=" + ma(r, n, i) + "&reqt=" + va + "&reqv=" + t.encryptType, t } var ya = { decodeRes: ga, uploadData: ka }; module.exports = ya;
